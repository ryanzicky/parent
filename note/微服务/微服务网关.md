### 微服务接入网关实现单点登录设计思路

#### 1. 架构设计分析

**网关整合OAuth2.0有两种思路**，一种是授权服务器生成令牌，所有请求统一在网关层验证，判断权限等操作；另一种是由各资源服务处理，网关只做请求转发。比较常用的是第一种，把API网关作为OAuth2.0的资源服务器角色，实现接入客户端权限拦截，令牌解析并转发当前登录用户信息给微服务，这样下有微服务就不需要关心令牌格式解析以及OAuth2.0相关机制了。

![image-20210624142007532](%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BD%91%E5%85%B3.assets/image-20210624142007532.png)

#### 2. 搭建微服务授权中心

**授权中心的认证依赖：**

	1. 第三方客户端的信息
 	2. 微服务的信息
 	3. 登录用户的信息

**测试模拟用户登录：**

 1.    授权码模式：

       授权码方式，指的是第三方应用先申请一个授权码，然后再用该授权码获取令牌。

       这中方式是最常用的流程，安全性也最高，它适用于那些有后端的Web应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。

       适用场景：目前市面上主流的第三方验证都是采用这种方式

       **它的步骤如下：**

       	1. 用户访问客户端，后者将前者导向授权服务器
        	2. 用户选择是否给予客户端授权
        	3. 假设用户给予授权，授权服务器将用户导向客户端事先指定的"重定向URI"，同时附上一个授权码
        	4. 客户端收到授权码，附上早先的重定向URI，向授权服务器申请令牌，这一步是在客户端的后台的服务器上完成的，对用户不可见
        	5. 授权服务器核对了授权码和重定向URI，确认无误后，向客户端发送访问令牌和更新令牌

	2. 密码模式：

    如果你高端信任某个应用，允许用户把用户名和密码，直接告诉该应用，该应用就是用密码，申请令牌，这种方式成为密码式

    适用场景：自家公司搭建的授权服务器

    因为授权服务器的security配置需要携带clientId和clientSecret，可以采用basic Auth的方式发送请求

    传参是token

    或者请求头配置Authorization

**Spring Security Oauth2 整合JWT**

​	JSON Web Token是一个开放标准(RFC 7519)，它定义了一种简洁的，自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。JWT可以使用HMAC算法或使用RSA的公钥/私钥对来签名，防止被篡改。

​	JWT令牌的优点：

		1. jwt基于json，方便解析
  		2. 可以在令牌中自定义丰富的内容，易扩展
  		3. 通过非对称加密算法及数字签名技术，JWT防止篡改，安全性高
  		4. 资源服务使用JWT可不依赖认证服务即可完成授权

   缺点：

 1.    JWT令牌较长，占存储空间比较大

       

       JWT组成

       ​	一个JWT实际上就是一个字符串，它由三部分组成，头部(header)，载荷(payload)与签名(signature)

       头部(header)：

       ​	头部用于描述关于该JWT的最基本信息，类型以及签名所用的算法(如HMACSHA256或RSA)等

       载荷(payload)：

       ​	第二部分是载荷，就是存放有效信息的地方。这个名字像是特指飞机上承载的货品，这些有效信息包含三个部分：

        1.    标准中注册的声明(建议但不强制使用)

        2.    公共的声明

              公共的声明可以添加任何信息，一般添加用户的相关信息或其他业务需要的必要信息， 但不建议添加敏感信息，因为该部分在客户端可解密

        3.    私有的声明

              私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息

       签名(signature)：

       ​	jwt的第三部分是一个签证信息，这个签证信息由三部分组成：

        	1. header(basae64后的)
        	2. payload(base64后的)
        	3. secret(盐，一定要保密)

       

       ​	这个部分需要base64加密后的header和base64加密后的payload使用，连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分：

       ```javascript
       var encodedString = base64UrlEncode(header) + '.' + base64UrlEncode(payload);
       var signature = HMACSHA256(encodedString, 'fox'); 
       // khA7TNYc7_0iELcDyTc7gHBZ_xfIcgbfpzUNWwQtzME
       ```

       将这三部分用.连接成一个完整的字符串，构成了最终的jwt

       **注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端的值这个secret，那就意味着客户端是可以自我签发jwt了。**

       

       

       

