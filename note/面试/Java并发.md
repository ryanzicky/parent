### 1. CountDownLatch 和 Semaphore 的区别和底层原理
```
CountDownLatch:
    CounDownLatch表示计数器，可以给CountDownLatch设置一个数字，一个线程调用
    CountDownLatch的await()方法将会阻塞，其他线程可以调用CountDownLatch的
    countDown()方法来对CountDownLatch中的数字减一，当数字被减成0后，所有
    await()方法都将被唤醒
    对应的底层原理就是，调用await()方法的线程会利用AQS排队，一旦数字被减为0，
    则会将AQS中排队的线程依次唤醒

Semaphore:
    Semaphore表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使用
    该信号量，通过acquire()方法来获取许可，如果没有许可可用则线程阻塞，并
    通过AQS来排队，可以通过release()方法来释放许可，当某个线程释放了某个许可
    后，会从AQS中正在排队的第一个线程开始依次唤醒，直到没有空闲许可
```



### 2. ReenTrantLock中的tryLock()和lock()的区别
```
reenTrantLock.lock(); // 阻塞加锁
boolean result = reenTrantLock.tryLock(); // 非阻塞

// 自旋锁
while (!reenTrantLock.tryLock()) {
    // 业务逻辑
}
```



### 3. ReenTrantLock中的公平锁和非公平锁的底层实现
```
首先不管是公平锁还是非公平锁，它们的底层实现都会使用AQS来进行排队，它们的区别在于:
线程在使用lock()方法加锁时，如果是公平锁，会先检查AQS队列中是否存在线程在排队，
如果有线程在排队，则当前线程也进行排队，如果是非公平锁，则不会去检查是否有线程在排队，
而是直接竞争锁

不管是公平锁还是非公平锁，一旦没竞争到锁，都会进行排队，当锁释放时，都是唤醒排在最
前面的线程，所以非公平锁只是体现了在线程加锁阶段，而没有体现在线程被唤醒阶段
另外，ReenTrantLock是可重入锁，不管是公平锁还是非公平锁都是可重入的
```



### 4. sleep(),wait(),join(),yield()的区别
```
1. 锁池:
    所有需要竞争同步锁的线程都会放在锁池当中，比如当前对象的锁已经被其中一个线程
    拿到，其他线程需要在这个锁池中等待，当前面的线程释放同步锁后锁池中的线程去
    竞争同步锁，当某个线程得到后会进入就绪队列进行等待cpu资源分配
2. 等待池:
    当我们调用wait()方法后，线程会放到等待池中，等待池的线程是不会去竞争同步锁，
    只有调用了notify()或notify()后等待池的线程才会开始去竞争锁，notify()是随机
    从等待池选出一个线程放到锁池，而notifyAll()是将等待池的所有线程释放到
    锁池中

1. sleep()是Thread类的静态本地方法，wait()是Object类的本地方法
2. sleep()方法不会释放lock，但是wail会释放，而且会加入到等待队列中
    sleep就是把cou的执行资格和执行权释放出去，不再运行此线程，当定时时间
    结束再取回cpu资源，参与cpu的调度
3. sleep方法不依赖于同步器synchronized，但是wait需要依赖synchronized关键字
4. sleep不需要被唤醒，但是wait需要
5. sleep一般用于当前线程休眠，或者轮询暂停操作，wait则多用于多线程之间的通信
6. sleep会放出cpu执行时间且强制上下文切换，而wait则不一定，wait后可能还是有机会
重新竞争到锁继续执行

yield()执行后线程直接进入就绪状态，马上释放了cpu的执行权，但是依然保留了cpu的执行
资格，所有有可能cpu下次进行线程调度还会让这个线程获取到执行权继续执行

join()执行后线程进入阻塞状态，例如在线程B中调用线程A的join()，那线程B会进入到阻塞
队列，直到线程A结束或中断线程
```



### 5. Synchroized的偏向锁，轻量级锁，重量级锁
```
1. 偏向锁: 在锁对象的对象头中记录一下当前获取到该所的线程ID，该线程下次如果又来
    获取锁就可以直接获取到锁了
2. 轻量级锁: 由偏向锁升级而来，当一个线程获取到锁后，此时这把锁是偏向锁，此时如果
    有第二个线程来竞争锁，偏向锁就会升级为轻量级锁，之所以叫轻量级锁，是为了和
    重量级锁区分开来，轻量级锁底层是通过自旋来实现的，并不会阻塞线程
3. 如果自旋次数过多任然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞
4. 自旋锁: 自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞
    和唤醒这两个步骤都是需要操作系统去进行的，比较消耗时间，自旋锁是线程通过CAS获取
    预期的一个标记，如果没有获取到锁，则继续循环获取，如果获取到了则表示获取到了锁，
    这个过程线程一直在运行中，相对而言没有使用太多的操作系统资源，比较轻量
```



### 6. Synchroized和ReenTrantLock的区别
```
1. Synchroized是一个关键字，ReenTrantLock是一个类
2. Synchroized会自动的加锁和释放锁，ReenTrantLock需要手动加锁和释放锁
3. Synchroized的底层是JVM层面的锁，ReenTrantLock是API层面的锁
4. Synchroized是非公平锁，ReenTrantLock可以选择公平锁或非公平锁
5. Synchroized锁的是对象，锁信息保存在对象头中，ReenTrantLock通过
    代码中int类型的state标识来标识锁的状态
6. Synchroized底层有一个锁升级的过程
```



### 7. ThreadLocal的底层原理
```
1. ThreadLocal是Java中所提供的线程本地存储机制，可以利用该机制将数据缓存
    在某个线程内部，该线程可以在任意时刻，任意方法中获取缓存的数据
2. ThreadLocal底层是通过ThreadLocalMap来实现的，每个Thread对象(不是
    ThreadLocal对象)中都存在一个ThreadLocalMap，Map的key为ThreadLocal
    对象，Map的value为需要缓存的值
3. 如果在线程池中使用ThreadLocal会造成内存泄漏，因为当ThreadLocal对象使用
    完之后，应该要把设置的key，value，也就是Entry对象进行回收，但线程池
    中的线程不会回收，而现场也难怪对象是通过强引用指向ThreadLocalMap，
    ThreadLocalMap也是通过强引用指向Entry对象，线程不被回收，Entry对象
    也就不会被回收，从而出现内存泄漏，解决办法是，在使用了ThreadLocal对象之后，
    手动调用ThreadLocal的remove方法，手动清除Entry对象

    Entry的key是ThreadLocal对象，并且是一个弱引用，当没有指向key的强引用后，
    该key就会被垃圾收集器回收
4. ThreadLocal经典的应用场景就是连接管理(一个线程持有一个连接，该连接对象可以在
    不同的方法之间进行传递，线程之间不共享同一个连接)
```



### 8. ThreadLocal的原理和使用场景
```
使用场景:
    1. 在进行对象跨层传递的时候，使用ThreadLocal可以避免多次传递，打破
        层次间的约束
    2. 线程间数据隔离
    3. 进行事务操作，用于存储线程事务信息
    4. 数据库连接，Session会话管理

    Sprin框架在事务开始时会给当前线程绑定一个JDBC Connection，在整个事务
    过程中都是使用该线程绑定的connection来执行数据库操作，实现了事务的隔离性，
    Spring框架就是使用ThreadLocal来实现这种隔离
```



### 9. ThreadLocal内存泄漏的原因，如何避免
```
内存泄漏为程序在申请内存后，无法释放已申请的内存空间，一次内存泄漏危害可以忽略，
但内存泄漏堆积后果很严重，无论多少内存，迟早会被占光，导致OOM
不再会被使用的对象或者变量占用的内存不能被回收，就是内存泄漏

强引用: 使用最普遍的引用(new),一个对象具有强引用，不会被垃圾回收器回收，当内存
    空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不
    回收这种对象
    如果想取消强引用和某个对象之间的关联，可以显示地将引用赋值为null，这样可以
    使JVM在合适的时间就会回收该对象
弱引用: JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象，在java中，
    用java.lang.ref.WeakReference类来表示。可以在缓存中使用弱引用

ThreadLocal的实现原理，每个Thread维护一个ThreadLocalMap，key为使用弱引用的
ThreadLocal实例，value为线程变量的副本

ThreadLocalMap使用ThreadLocal的弱引用作为key，如果一个ThreadLocal不存在外部
强引用时，key(ThreadLocal)势必会被GC回收，这样会导致ThreadLocalMap中key为null，
而value还存在着强引用，只有Thread线程退出以后，value的强引用联调才会断掉，但如果
当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链

key使用强引用:
    当ThreadLocalMap的可以为强引用回收ThreadLocal时，因为ThreadLocalMap还
    持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry
    内存泄漏
key使用弱引用:
    当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有
    ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，
    在下一次ThreadLocalMap调用set(),get(),remove()方法时会被清除value值

因此，ThreadLocal内存泄漏的根源是: 由于ThreadLocalMap的生命周期跟Thread一样长，
如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用

ThreadLocal正确的使用方法:
    1. 每次使用完ThreadLocal都调用它的remove()方法清除数据
    2. 将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的
        强引用，也就能保证任何时候通过ThreadLocal的弱引用访问到Entry的value值，
        进而清除掉
```



### 10. Thread Runnable的区别
```
Thread和Runnable的实质是继承关系，没有可比性，无论使用Runnable还是Thread，
都会new Thread，然后执行run方法，用法上，如果有复杂的线程操作需求，那就选择继承Thread，
如果只是简单的执行一个任务，那就实现Runnable
```



### 11. 如何查看线程死锁
```
1. 可以通过jstack命令来进行查看，jstack命令中会显示发生了死锁的线程
2. 或者两个线程去操作数据库时，数据库发生了死锁，这是可以查询数据库死锁的情况
    1. 查询是否锁表
        show OPEN TABLES where In_user > 0;
    2. 查询进程
        show processlist
    3. 查看正在锁的事务
        SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;
    4. 查看等待锁的事务
        SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS_WAITS;
```



### 12. 线程之间如何进行通讯
```
1. 线程之间可以通过共享内存或基于网路来进行通信
2. 如果是通过共享内存来进行通信，则需要考虑并发问题，什么时候阻塞，什么时候唤醒
3. 像Java中的wait(),notify()就是阻塞和唤醒
4. 通过网络就比较简单了，通过网络连接将通信数据发送给对方，当然也要考虑到并发问题，
    处理方式就是加锁等方式
```



### 13. 并发，并行，串行的区别
```
串行在时间上不可能发生重叠，前一个任务没搞定，下一个任务就只能等着
并行在时间上是重叠的，两个任务在同一时刻互不干扰的同时执行
并发允许两个任务彼此干扰，同一时间点，只有一个任务运行，交替执行
```



### 14. Java如何开启线程，怎么保证线程安全
```
线程和进程的区别:
    进程是操作系统进行资源分配的最小单元，线程是操作系统进行任务分配的最小单元，
    线程隶属于进程
如何开启线程:
    1. 继承Thread类，重写run方法
    2. 实现Runnable接口，实现run方法
    3. 实现Callable接口，实现call方法，通过FutureTask创建一个线程，
        获取到线程执行的返回值
    4. 通过线程池来开启线程

    单继承，多实现
    start()和run()的区别: 
        start()内部调用run()方法开启线程，直接调用run()方法是单纯的方法调用

怎么保证线程安全:
    加锁：
        1. JVM提供的锁，也就是Synchroized关键字
            偏向锁，轻量级锁，重量级锁
        2. JDK提供的各种锁Lock
```




### 15. Volatile和Synchroized有什么区别？Volatile能不能保证线程安全？
```
1. Synchroized关键字，用来加锁。Volatile只是保持变量的线程可见性，
    通常适用于一个线程写，多个线程读的场景
2. Volatile只能保证线程可见性，不能保证原子性
```



### 16. DCL(Double Check Lock)单例为什么要加入Volatile
```
Volatile防止指令重排。在DCL中，防止高并发情况下，指令重排导致的问题
    as-if-serial
    happens-before
对象创建过程:
    1. 堆内存开辟空间，分配内存，设默认值
    2. 初始化
    3. 建立指针对应关系
```



### 17. Java线程锁机制是怎样的？偏向锁，轻量级锁，重量级锁有什么区别？
```
1. Java的锁就是在对象的Markword中记录一个锁状态，无锁，偏向锁，轻量级锁，
    重量级锁对应不同的锁状态
2. Java的锁机制就是根据资源竞争的激烈程度不断进行锁升级的过程
```



### 锁机制是如何升级的？
    1. 偏向锁是否打开
        未打开: 无锁 -> 轻量级锁 -> 重量级锁
        已打开: 无锁 -> 匿名偏向 -> 偏向锁 -> 轻量级锁 -> 重量级锁

### AQS是什么？AQS如何实现可重入锁？
    1. AQS(AbstractQueuedSynchronizer)是一个Java线程同步的框架，
        是JDK中很多锁工具的核心实现框架
    2. 在AQS中，维护了一个信号量state和一个线程组成的双向链表队列，
        其中，这个线程队列，就是用来给线程排队的，而state就像是一个红绿灯，
        用来控制线程排队或者放行的，在不同的场景下，有不同的意义。
    3. 在可重入锁这个场景下，state就用来表示加锁的次数，0表示无锁，
        每加一次锁，state就加1，释放锁就减1。

### 有A,B,C三个线程，如何保证三个线程同时执行？如何在并发情况下保证三个线程依次执行？
### 如何保证三个线程有序交错执行？
    CountDownLatch:
        门栓，保证线程同时执行
    CylicBarrier:
        栅栏，保证线程依次执行
    Semaphore:
        信号量，保证线程有序交错进行
    Volatile:
        线程通知，顺序执行

### 如何对一个字符串快速进行排序
    Fork/Join 框架
    先拆分，后合并

### 并发三大特性
    原子性:
        原子性是指在一个操作中cpu不可以在中途暂停然后再调度，即不被打断操作，
        要么全部执行完成，要么都不执行
    
        i++
            1. 将i从主存读取到工作内存中的副本中
            2. +1的运算
            3. 将结果写入工作内存
            4. 将工作内存的值刷回主存(什么时候刷入由操作系统决定，不确定的)
    
    可见性:
        总线lock
        MESI: 缓存一致性协议
        
    有序性:
        虚拟机在进行代码编译时，对于那些改变顺序之后不会对最终结果造成影响的代码，
        虚拟机不一定会按照我们写的代码顺序来执行，有可能将他们重排序。实际上，对于
        有些代码进行重排序之后，虽然对变量的值没有造成影响，但有可能会出现线程安全
        问题。

### 对线程安全的理解
    不是线程安全，应该是内存安全，堆是共享内存，可以被所有线程访问
    当多个线程访问同一个对象时，如果不用进行额外的同步控制或其他的协调操作，调用
    这个对象的行为都可以获取正确的结果，我们就说这个对象是线程安全的
    
    堆是进程和线程共有的空间，分全局堆和局部堆，全局堆就是所有没有分配的空间，局部堆
    就是用户分配的空间，堆在操作系统对进程初始化的时候分配，运行过程中也可以向系统要
    额外的堆，但是用完了要还给操作系统，要不然就是内存泄漏
        在java中，堆是java虚拟机所管理的内存中最大的一块，是所有线程共享的一块内存
        区域，在虚拟机启动时创建，堆所在的内存区域的唯一目的就是存放对象实例，几乎
        所有的对象实例以及数组都在这里分配内存
    
    栈是每个线程独有的，保存其状态和局部自动变量的，栈在线程开始的时候初始化，每个线程的栈
    互相独立，因此，栈是线程安全的，操作系统在切换线程的时候会自动切换栈，栈空间不需要在高级
    语言里面显示的分配和释放。

### 并发编程三要素
    原子性:
        不可分割的操作，多个步骤要保证同时成功或同时失败
    有序性:
        程序执行的顺序和代码的顺序保持一致
    可见性:
        一个线程对共享变量的修改，另一个线程能立马看到

### Java死锁如何避免
    造成死锁的原因:
        1. 一个资源每次只能被一个线程使用
        2. 一个线程在阻塞等待某个资源时，不释放已占有资源
        3. 一个线程已经获得的资源，在未使用完之前，不能被强行剥夺
        4. 若干线程行程头尾相接的循环等待资源
    这是造成死锁的四个必要条件，如果要避免死锁，只需要不满足其中某一个条件即可，而其中
    前3个条件是作为锁要符合的条件，所以要避免死锁就需要打破第4个条件，不出现循环等待
    锁的关系
    
    在开发过程中:
        1. 要注意加锁顺序，保证每个线程按同样的顺序加锁
        2. 要注意加锁时限，可以针对锁设置一个超时时间
        3. 要注意死锁检查，这是一种预防机制，确保在第一时间发现死锁并进行解决

### 提交任务时，线程池队列已满，这时会发生什么
    1. 如果使用的是无界队列，那么可以继续提交任务是没关系的
    2. 如果使用的是有界队列，提交任务时，如果队列满了，如果核心线程数没有达到上限，
        那么则增加线程，如果线程数已经达到了最大值，则使用拒绝策略进行拒绝

### volatile如何保证可见性，有序性
    1. 对于加了volatile关键字的成员变量，在对这个变量进行修改时，会直接将CPU高级
        缓存中的数据写回到主内存，对这个变量的读取也回直接从主内存中读取，从而保证了
        可见性
    2. 在对volatile修饰的成员变量进行读写时，会插入内存屏障，而内存屏障可以达到禁止
        重排序的效果，从而可以保证有序性

### Synchroized的自旋锁，偏向锁，轻量级锁，重量级锁
    1. 偏向锁: 在锁对象的对象头中记录一下当前获取到该锁的线程ID，该线程下次如果又来
        获取到锁就可以直接获取到了
    2. 轻量级锁: 由偏向锁升级而来，当一个线程获取到锁后，此时这把锁是偏向锁，此时如果
        有第二个线程来竞争锁，偏向锁就会升级为轻量级锁，之所以叫轻量级锁，是为了和重量
        级锁区分开来，轻量级锁底层是通过自旋来实现的，并不会阻塞线程
    3. 如果自旋次数过多任然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞
    4. 自旋锁: 自旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就无所谓唤醒线程，阻塞
        和唤醒这两个步骤都是需要操作系统去进行的，比较消耗时间，自旋锁是线程通过CAS获取预期
        的一个标记，如果没有获取到，则继续循环获取，如果获取到了则表示获取到了锁，这个过程
        线程一直在进行中，相对而言没有使用太多的操作系统资源，比较轻量

### 线程池原理，FixedThreadPool用的阻塞队列是什么？
    1. 线程池内部是通过队列+线程来实现的，当我们利用线程池执行任务时:
        1. 如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲
            状态，也要创建新的线程来处理被添加的任务
        2. 如果此时线程池中的数量等于corePoolSize，但是缓冲队列workQueue未满，
            那么任务被放入缓冲队列
        3. 如果此时线程池中的数量大于等于corePoolSize，缓冲队列workQueue满了，
            并且线程池中的数量小于maximumPoolSize，创建新的线程来处理被添加的任务
        4. 如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满了，并且
            线程池中的数量等于maximumPoolSize，那么通过handler所指定的策略来
            处理此任务
        5. 当线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，  
            线程将被终止，这样，线程池就可以动态的调整池中的线程数
    
    2. FixedThreadPool代表定长线程池，底层用的LinkedBlockingQueue，表示无界
        的阻塞队列

### 如何理解volatile关键字
    在并发领域中，存在三大特性: 原子性，有序性，可见性，volatile关键字用来修饰对象的
    属性，在并发环境下可以保证这个属性的可见性，对于加了volatile关键字的属性，在对这个
    属性进行修改时，会直接将PCU高级缓存中的数据写回到主内存，对这个变量的读取也会直接从
    主内存中读取，从而保证了可见性，底层是通过操作系统的内存屏障来实现的，由于使用了内存
    屏障，所以会禁止指令重排，所以就同时保证了有序性，在很多并发场景下，如果利用好volatile
    关键字可以很好的提高执行效率

### 守护线程
    守护线程: 为所有非守护线程提供服务的线程;任何一个守护线程都是整个JVM中所有非守护线程
        的保姆
    注意: 守护线程的终止是自身无法控制的，因此签完不要把IO，File等重要操作逻辑分配给它，
        因为它不靠谱
    
    守护线程的作用是什么?
        GC垃圾回收线程
    
    应用场景:
        1. 为其他线程提供服务支持情况
        2. 在任何情况下，程序结束时，这个线程必须且立刻关闭，就可以作为守护线程来使用，
            反之，如歌一个正在执行某个操作的线程必须要正确地关闭调否则就会出现不好的后果
            的话，那么这个线程就不能是守护线程，而是用户线程，通常都是些关键的事务，
            例如数据库录入或者更新
    
    thread.setDaemon(true)必须在thread.start()之前设置，否则会爆出
    IllegalThreadStateException，不能把正在运行的常规线程设置为守护线程
    
    在Daemon线程中产生的新线程也是Daemon
    
    守护线程不能访问固有资源，比如读写操作或者计算逻辑，因为它会在任何时候甚至在一个操作
    的中间发生中断
    Java自带的多线程框架，比如ExecutorService，会将守护线程转换为用户线程，所以如果
    要使用后台线程就不能用Java的线程池

### 线程池参数
    1. 降低资源消耗;提高线程利用率，降低创建和销毁线程的消耗
    2. 提高响应速度;任务来了，直接有线程可用可执行，而不是先创建线程，再执行
    3. 提高线程的可管理型;线程是稀缺资源，使用线程池可以统一分配调优监控
        · corePoolSize: 代表核心线程数，也就是正常情况下创建工作的线程数，这些线程
            创建后并不会消除，而是一种常驻线程
        · maxinumPoolSize: 代表的是最大线程数，它与核心线程数相对应，表示最大允许被
            创建的线程数，比如当前任务较多，将核心线程数都用完了，还无法满足需求时，就
            会创建新的线程，但是线程池内线程总数不会超过最大线程数
        · keepAliveTime,unit: 表示超出核心线程数之外的线程的空闲存活时间，也就是核心
            线程不会消除，但是超出核心线程数的部分线程如果空闲一定的时间则会被消除
        · workQueue: 用来存放待执行的任务，假设我们现在核心线程都已被使用，还有任务进来
            则全部放入队列，直到整个队列被放慢但任务还在持续进入则会开始创建新的线程
        · ThreadFactory: 实际上是一个线程工厂，用来生产线程执行任务，我们可以选择使用
            默认的创建工厂，产生测线程都在同一个组内，拥有相同的优先级，且都不是守护线程。
            当然我们也可以选择自定义线程工厂，一般我们会根据业务来制定不同的线程工厂
        · Handler: 任务拒绝策略，有两种情况，第一种是当我们调用shutdown()等方法关闭
            线程池后，这时候即使线程池内部还有没执行完的任务正在执行，但是由于线程池已经
            关闭，我们再继续想线程池提交任务就会遭到拒绝，另一种情况局势当达到最大线程数，
            线程池已经没有能力继续处理新提交的任务时，这是也就拒绝

### 线程池处理流程
    1. 核心线程数未满，创建核心线程执行
    2. 核心线程数已满，判断任务队列是否已满，任务队列未满，将任务放入到任务队列
    3. 任务队列已满，判断最大线程数是否已满，未满，创建临时线程执行
        (临时线程受过期时间限制)
    4. 最大线程数已满，根据拒绝策略处理任务

### 线程池中线程复用原理
    线程池将线程和任务进行解耦，线程是线程，任务是任务，摆脱了之前通过Thread创建
    线程时的一个线程必须对应一个任务的限制
    在线程池中，同一个线程可以从阻塞队列中不断获取新任务执行，其核心原理在于线程池对
    Thread进行了封装，并不是每次执行任务都会调用Thread.start()来创建新线程，而是
    让每个线程去执行一个"循环任务",在这个"循环任务"中不停检查是否有任务需要被执行，
    如果有则直接执行，也就是调用任务中的run方法，将run方法当成一个普通的方法执行，
    通过这种方式只是用固定的线程就将所有任务的run方法串联起来

### 线程池中阻塞队列的作用？为什么是先添加队列而不是先创建最大线程？
    1. 一般的队列只能保证作为一个有限长度的缓冲区，如果超出了缓冲长度，就无法保留当前
        的任务了，阻塞队列可以通过阻塞保留住当前想要继续入队的队列
        阻塞队列可以保证任务队列中没有任务时阻塞获取任务的线程，使得线程进入wait状态，
        释放cpu资源
        阻塞队列自带阻塞和唤醒的功能，不需要额外处理，无任务执行时，线程池利用阻塞队列
        的take方法挂起，从而维持核心线程的存活，不至于一直占用cpu资源
    
    2. 在创建新线程的时候，是要获取全局锁的，这个时候其他的就得阻塞，影响了整体效率

### 线程的生命周期和状态
    1. 线程通常有五种状态，创建，就绪，运行，阻塞和死亡状态
    2. 阻塞有分三种:
        1. 等待阻塞: 运行的线程执行wait()方法，该线程会释放占用的资源，JVM会把该
            线程放入"等待池"中，进入这个状态后，是不能自动唤醒的，必须依靠其他线程
            调用notify或notifyAll()方法才能被唤醒，wait是object的方法
        2. 同步阻塞: 运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则
            JVM会把该线程放入"锁池"中
        3. 其他阻塞: 运行的线程执行sleep或join方法，或者发出了I/O请求时，JVM会
            把该线程设置为阻塞状态，当sleep状态超时，join等待线程终止或者超时，
            或者I/O处理完毕时，线程重新转入就绪状态，sleep是Thread类的静态方法
    
    新建状态(NEW): 新创建了一个线程对象
    就绪状态(Runnable): 线程对象创建后，其他线程调用了该对象的start方法，该状态的线程
        位于可执行线程池中，变得可运行，等待获取CPU的使用权
    运行状态(Running): 就绪状态的线程获取了CPU,执行程序代码
    阻塞状态(Blocked): 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行，知道线程
        进入就绪状态，才有机会转到运行状态
    死亡状态(Dead): 线程执行完了或者因为一场退出了run方法，该线程结束生命周期


​    




​    
​    
​        




​    