### 1. TCP和UDP有什么区别？TCP为什么是三次握手，而不是两次

**TCP（Transfer Control Protocol）：**是一种面向连接的，可靠的，传输层通信协议。

​	特点：面向连接的，点对点的通信，高可靠的。效率比较低，占用的系统资源比较多。

**UDP（User Datagramp Protocol）：**是一种无连接的，不可靠的，传输层通信协议。

​	特点：不需要连接，发送方不管接收方有没有准备好，直接发消息；可以进行广播发送的；传输不可靠，有可能丢失消息；效率比较高；协议比较简单，占用的系统资源比较少。

**TCP建立连接三次握手，断开连接四次挥手。**

如果是两次握手，可能造成连接资源浪费的情况。

### 2. Java有哪几种IO模型？有什么区别？

**BIO：**同步阻塞IO.可靠性差，吞吐量低，适用于连接比较少且比较固定的场景。JDK1.4之前唯一的选择。编程模型是最简单的。

![BIO模型](%E7%BD%91%E7%BB%9C.assets/BIO%E6%A8%A1%E5%9E%8B-1637214466735.png)

**NIO：**同步非阻塞IO。可靠性比较好，吞吐量也比较高，适用于连接比较多并且连接比较短的场景（轻操作），例如聊天室。JDK1.4开始支持。编程模型最复杂。

![NIO模型](%E7%BD%91%E7%BB%9C.assets/NIO%E6%A8%A1%E5%9E%8B.png)

**AIO：**异步非阻塞IO。可靠性最好的，吞吐量也是非常高。适用于连接比较多，并且连接比较长（重操作）。例如相册服务器。JDK1.7开始支持。编程模型比较简单，需要操作系统来支持。

![AIO模型](%E7%BD%91%E7%BB%9C.assets/AIO%E6%A8%A1%E5%9E%8B.png)

同步，异步：针对请求

阻塞，非阻塞：针对客户端

在一个网络请求中，客户端会发一个请求到服务端

1.  客户端发送请求后，就一直等待服务端响应。客户端：阻塞状态。请求：同步
2.  客户端发送请求后，就去干别的事情了，时不时的过来检查服务端是否给出了响应。客户端：非阻塞。请求：同步
3.  换成异步请求，客户端发了请求后，等着服务端返回响应。客户端：阻塞。请求：异步
4.  客户端发了请求后，就去干别的事情了。等到服务端给出响应后，再过来处理业务逻辑。客户端：非阻塞。请求：异步。



### 3. Java NIO的几个核心组件是什么？分别有什么作用

![NIO组件模型](%E7%BD%91%E7%BB%9C.assets/NIO%E7%BB%84%E4%BB%B6%E6%A8%A1%E5%9E%8B.png)

-   Selector：selector会根据channel上发生的读写事件，将请求交由某个空闲的线程处理。
-   Channel：类似于一个流，每个Channel对应一个Buffer缓冲区。channel会注册到selector。selector对应一个或者多个线程
-   Buffer：Buffer和Channel都是可读可写的。

### 4. Select，poll和epoll有什么区别？

他们是NIO中多路复用的三种实现机制，是由Linux操作系统提供的。

用户空间和内核空间：操作系统为了保护系统安全，将内核划分为两个部分，一个是用户空间，一个是内核空间。用户空间不能直接访问底层的硬件设备，必须通过内核空间。

文件描述符（File Descriptor）FD：是一个抽象概念，形式上是一个整数，实际上是一个索引值，指向内核中为每个进程维护进程所打开的文件的记录表，当程序打开一个文件或者创建一个文件时，内核就会想进程返回一个FD。UNIX，Linux。

select机制：会维护一个FD的集合fd_set。将fd_set从用户空间复制到内核空间，激活socket。x64 2048。

poll机制：和select机制是差不多的，把fd_set结构进行了优化，FD集合的大小就突破了操作系统的限制。pollfd结构来代替fd_set，通过链表实现的。

epoll机制：Event Poll。epoll不再扫描所有的FD，只将用户关心的FD事件存放到内核的一个时间表当中。这样，可以减少用户空间与内核空间之前需要拷贝的数据。

简单总结：

|        | 操作方式 | 底层实现 | 最大连接数 | IO效率 |
| ------ | -------- | -------- | ---------- | ------ |
| select | 遍历     | 数组     | 受限于内核 | 一般   |
| poll   | 遍历     | 链表     | 无上限     | 一般   |
| epoll  | 事件回调 | 红黑树   | 无上限     | 高     |

**java的NIO当中是用的哪种机制？**

可以查看DefaultSelectorProvider源码。在windows下，WindowsSelectorProvider。

而Linux下，根据Linux的内核版本，2.6版本以上，就是EpollSelectorProvider，否则就是默认的PollSelectorProvider。

select：1984年出现

poll：1997年出现

epoll：2002年出现

### 5. 什么是认证和授权？如何设计一个权限认证框架？

认证：就是对系统访问者的身份进行确认，用户名密码登录，二维码登录，手机短信登录，指纹，刷脸。。。

授权：就是对系统访问者的行为进行控制。授权通常是在认证之后，对系统内的用户隐私数据进行保护。后台接口访问权限，前台空间的访问权限。

RBAC模式：主体->角色->资源->访问系统的行为。

认证和授权是对一个权限认证框架进行扩展的两个主要的方面。

### 6. 什么是OAuth2.0协议？有哪几种认证方式？什么是JWT令牌？和普通令牌有什么区别？

OAuth2.0是一个开放标准，允许用户授权第三方应用程序访问它们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方应用或分享它们数据的所有内容。

OAuth2.0协议的认证流程，简单理解，就是允许我们将之前的授权和认证过程交给一个独立的第三方进行担保。

OAuth2.0协议有四种认证方式：

1.  授权码模式
2.  简化模式
3.  密码模式
4.  客户端模式

### 7. 什么是SSO？与OAuth2.0有什么关系？

OAuth2.0的使用场景通常称为联合登录，**一处注册，多处使用。**

SSO Single Sign On 单点登录。**一处登录，多处同时登录。**

SSO 的实现关键是将Session信息集中存储。Spring Security。

### 8. 什么是嵌入式服务器？

节省了下载安装tomcat，应用也不需要在打war包，然后放到webapp目录下再运行。

只需要一个安装了Java的虚拟机，就可以直接在上面部署应用程序了。

SpringBoot已经内置了tomcat.jar，运行main方法时会去启动tomcat，并利用tomcat的spi机制加载springMVC。

### 9. 什么是OAuth2.0协议？有哪几种认证方式？什么是JWT令牌？和普通令牌有什么区别？

OAuth2.0是一个开放标准，允许用户授权第三方应用程序访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方应用或分享他们数据的所有内容。

OAuth2.0协议的认证流程，简单理解，就是允许我们将之前的授权和认证过程交给一个独立的第三方进行担保。

OAuth2.0协议有四种认证方式：

1.  授权码模式：
2.  简化模式：
3.  密码模式：
4.  客户端模式：

在梳理OAuth2.0协议流程的过程中，其实有一个主线，就是三方参与者之间的信任程度。

### 10 如何设计一个开放授权平台？

开放授权平台可以按照认证和授权两个方向来梳理

1.  认证：就可以按照OAuth2.0协议来规划认证的过程。

2.  授权：首先需要待接入的第三方应用在开放授权平台进行注册，注册需要提供几个必要的信息。clientID，消息推送地址，密钥（一对公私钥，私钥由授权平台自己保存，公钥分发给第三方应用）。

    然后，第三方应用引导客户发起请求时，采用公钥进行参数加密，授权开放平台使用对应的私钥解密。

    接下来：授权开放平台同步响应第三方应用的只是消息是否处理成功的结果，而真正的业务数据由授权开放平台异步推送给第三方应用预留的推送地址。

### 11.  什么是CSRF攻击？如何防止？

CSRF：Cross Site Request Forgery 跨站请求伪造

一个正常的请求会将合法用户的session id保存到浏览器的cookie。这时候，如果用户在浏览器中打开另一个tab页，那这个tab页也可以获得浏览器的cookie。黑客就可以利用这个cookie信息进行攻击。

攻击过程：

1.  某银行网站A可以以GET请求的方式发起转账操作。www.xxx.com/transfer.do?accountNum=100&money=1000

    accountNum表示目标账户。这个请求肯定是需要登录才可以正常访问的。

2.  攻击者在某个论坛或者网站上，上传一个图片，链接地址是 www.xxx.com/transfer.do?accountNum=888&money=10000 其中这个accountNum就是攻击者自己的银行账户。

3.  如果有一个用户，登录了银行网站，然后又打开浏览器的另一个tab页，点击了这个图片。这时，银行就会受理到一个带有正确cookie的请求，就会完成转账，用户的钱就被盗了。

CSRF方式：

1.  尽量使用POST请求，限制GET请求。POST请求可以带请求体，攻击者就不容易伪造出请求。

2.  将cookie设置为HttpOnly：response.setHeader("Set-Cookie","cookiename=cookievalue;HttpOnly")。

3.  增加token：

    在请求中放入一个攻击者无法伪造的信息，并且该信息不存在与cookie当中。

    <input type='hidden' value='xxxxx'/>

    这也是Spring Security框架中采用的防范方式。

### 12. HTTPS是如何保证安全传输的

Https是通过使用对称加密，非对称加密，数字证书等方式来保证数据的安全传输

1.  客户端向服务端发送数据之前，需要先建立TCP连接，所以需要先建立TCP连接，建立完TCP连接后，服务端会先给客户端发送公钥，客户端拿到公钥后就可以用来加密数据了，服务端到时候接收到数据就可以用私钥解密数据，这中就是通过非对称加密来传输数据。
2.  不过非对称加密比对称加密要慢，所以不能直接使用非对称加密来传输请求数据，所以可以通过非对称加密的方式来传输对称加密的密钥，之后就可以使用对称加密来传输请求数据了。
3.  但是仅仅通过非对称加密+对称加密还不足以能保证数据传输的绝对安全，因为服务端向客户端发送公钥时，可能会被截胡。
4.  所以为了安全的传输公钥，需要用到数字证书，数字证书是具有公信力，大家都认可的，服务端向客户端发送公钥时，可以把公钥和服务端相关信息通过hash算法生成消息摘要，再通过数字证书提供的私钥对消息摘要进行加密生成数字签名，再把没进行hahs算法之前的信息和数字签名一起形成数字证书，最后把数字证书发送给客户端，客户端收到数字证书后，就会通过数字证书提供的公钥来解密数字证书，从而得到非对称加密要用到的公钥。
5.  在这个过程中，计算有中间人拦截到服务端发出来的数字证书，虽然它可以解密得到非对称加密要用到的公钥，但是中间人是没办法伪造数字证书发给客户端的，因为客户端上内嵌的数字证书是全球具有公信力的，某个网站如果要支持https，都是需要申请数字证书的私钥的，中间人如果要生成能被客户端解析的数字证书，也是要申请私钥的，所以是比较安全了。

### 13. 浏览器发出一个请求到收到响应经历了哪些步骤？

1.  浏览器解析用户输入的URL，生成一个HTTP格式的请求。
2.  先根据URL域名从本地hosts文件查找是否有映射IP，如果没有就将域名发送给电脑所配置的DNS进行域名解析，得到IP地址。
3.  浏览器通过操作系统将请求通过四层网络协议发送出去。
4.  途中可能经过各种路由器，交换机，最终到达服务器。
5.  服务器收到请求后，根据请求所指定的端口，将请求传递给绑定了该端口的应用程序，比如8080被tomcat占用了。
6.  tomcat接收到请求数据后，按照http协议的格式进行解析，解析得到所要访问的servlet、
7.  然后servlet来处理这个请求，如果是SpringMVC中DispatchServlet，那么则会找到对应的Controller中的方法，并执行该方法得到结果。
8.  Tomcat得到响应结果后封装成HTTP响应的格式，并在此通过网络发送给浏览器所在的服务器。
9.  浏览器所在的服务器拿到结果后再传递给浏览器，浏览器则负责解析并渲染。

### 14. epoll和poll的区别

1.  select模型，使用的是数组来存储socket连接文件描述符，容量是固定的，需要通过轮询来判断是否发生了IO事件
2.  poll模型，使用的是链表聊存储socket连接文件描述符，容量是不固定的，同样需要通过轮询来判断是否发生IO事件
3.  epoll模型，epoll和poll是完全不同的，epoll是一种事件通知模型，当发生了IO事件，应用程序才进行IO操作，不需要像poll模型那样主动去轮询。

### 15. tomcat中为什么要使用自定义类加载器

一个tomcat可以部署多个应用，每个应用中都存在很多类，并且各个应用中的类是独立的，全类名是可以相同的。一个tomcat，不管内部部署了多少应用，tomcat启动之后就是一个java进程，也就是一个jvm，所以如果tomcat只存在一个类加载器，比如默认的AppClassLoader，那么就只能加载一个同名类。tomcat中，会为部署的每个应用都生成一个类加载器实例，名字叫做WebAppClassLoader，这样tomcat中每个应用可以使用自己的类加载器去加载自己的类，从而达到应用之间的类隔离，不出现冲突，另外tomcat还利用自定义类加载器实现了热加载功能。

WebAppClassLoader1类加载实例+类名

WebAppClassLoader2类加载实例+类名

**热加载：WebAppClassLoader1类加载实例+A类名  修改时间 重新的去创建一个WebAppClassLoader1**

### 16. 零拷贝是什么？

零拷贝指的是，应用程序在需要把内核空间中的一块区域数据转移到另外一块内核区域时，不需要经过先复制到用户空间，再转移到目标内核区域了，直接实现转移。

### 17. 跨域请求是什么？有什么问题？怎么解决？

跨域是指浏览器在发起网络请求时，会检查该请求所对应的协议，域名，端口和当前网页是否一致，如果不一致则浏览器会进行限制，比如在www.baidu.com的某个网页中，如果使用ajax去访问www.jd.com是不行的，但是如果img，iframe，script等标签的src属性去访问则是可以的，之所以浏览器要做这层限制，是为了用户信息安全，但是如果开发者想要绕过这层限制也是可以的：

1.  response添加header，比如resp.setHeader("Access-Control-Allow-Origin", "*")；表示可以访问所有网站，不受是否同源的限制。
2.  jsonp的方式，该技术底层就是基于script标签来实现的，因为script标签是可以跨域的。
3.  后台自己控制，先访问通域名下的接口，然后在接口中再去使用HTTPClient等工具去调用目标接口。
4.  网关，和第三种方式类似，都是交给后台服务来进行跨域访问。

### 18. TCP的三次握手和四次挥手

TCP协议是7层网络协议中的传输层协议，负责数据的可靠传输。

在简历TCP连接时，需要通过三次握手来建立，过程是：

1.  客户端向服务端发送一个SYN
2.  服务端接收到SYN后，给客户端发送一个SYN_ACK
3.  客户端接收到SYN_ACK后，再给客户端发送一个ACK

在断开TCP连接时，需要通过四次挥手来断开，过程是：

1.  客户端向服务端发送FIN
2.  服务端接收FIN后，向客户端发送ACK，表示我接收到了断开连接的请求，客户端你可以不发数据了，不过服务端这边可能还有数据正在处理
3.  服务端处理完所有数据后，向客户端发送FIN，表示服务端现在可以断开连接
4.  客户端收到服务端的FIN，向服务端发送ACK，表示客户端会断开连接了

### 19. Cookie和Session有什么区别？如果没有Cookie，Session还能进行身份验证吗？

当服务器tomcat第一次接收到客户端的请求时，会开辟一块独立的session空间，建立一个session对象，同时会生成一个session id，通过响应头的方式保存在客户端浏览器的cookie中，以后客户端的每次请求，都会在请求头部带上session id，这样就可以对应上服务端的一些会话的相关信息，比如用户的登录状态。

如果没有客户端的Cookie，Session是无法进行身份验证。

**当服务端从单体应用升级为分布式之后，cookie+session这种机制要怎么扩展？**

1.  session黏贴：在负载均衡中，通过一个机制保证同一个客户端的所有请求都会转发到同一个tomcat实例当中，问题：当这个tomcat实例出现问题之后，请求就会被转发到其他实例，这时候用户的session信息就丢失了。
2.  session复制：当一个tomcat实例上保存了session信息后，主动价格session复制到集群中的其他实例。问题：复制是需要时间的，在复制过程中，容易产生session信息丢失。
3.  session共享：就是讲服务端的session信息保存到一个第三方中，比如Redis。

### 20. tomcat如何进行优化

对于tomcat调优，可以从两个方面来进行调整：内存和线程。

首先启动tomcat，实际上就是启动了一个jvm，所以可以按jvm调优的方式来进行调整，从而达到tomcat优化的目的。

另外tomcat中设计了一些缓冲区，比如appReadBufSize，bufferPoolSize等缓冲区来提高吞吐量。

还可以调整tomcat的线程，比如调整minSpareThreads参数来改变Tomcat空闲时的线程数，调整maxThreads参数来设置tomcat处理连接的最大线程数。

并且还可以调整IO模型，比如使用NIO，APR这种相比于BIO更加高效的IO模型。

### 21. Netty是什么？和Tomcat有什么区别？特点是什么？

Netty是一个基于NIO的异步网络通信框架，性能高，封装了原生NIO编码的复杂度，开发者可以直接使用Netty来开发高效率的各种网络服务器，并且编码简单。

Tomcat是一个Web服务器，是一个Servlet容器，基本上Tomcat内部只会运行Server程序，并处理HTTP请求，而Netty封装的是底层IO模型，关注的是网络数据的传输，而不关心具体的协议，可定制性更高。

Netty的特点：

1.  异步，NIO的网络通信框架
2.  高性能
3.  高扩展，高定制性
4.  易用性

### 22. Netty体现在哪些方面

1.  NIO模型：用最少的资源做更多的事情
2.  内存零拷贝：尽量减少不必要的内存拷贝，实现了更高效率的传输
3.  内存池设计：内存可以重用，主要指直接内存。
4.  串行化处理读写：避免使用锁带来的性能开销，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。表面上看，串行化设计有CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队里-多个工作线程模型性能更优
5.  高性能的序列化协议：支持protobuf等高性能序列化协议
6.  高效并发编程的体现：volatile的大量，正确使用；CAS和元子类的广泛使用；线程安全容器的使用；通过读写锁提升并发性能。

### 23. Netty线程模型是怎么样的？

Netty同时支持Reactor单线程模型，Reactor多线程模型和Reactor主从多线程模型，用户可根据启动参数配置在这三种模型之间切换。

服务端启动时，通常会创建两个NioEventLoopGroup实例，对应了两个独立的Reactor线程池，bossGroup负责处理客户端的连接请求，workGroup负责处理I/O相关的操作，执行系统Task，定时任务Task等。用户可根据服务端引导类ServerBootStrap配置参数选择Reactor线程模型，进而最大限度地满足用户的定制化需求。

### 24. BIO，NIO，AIO分别是什么？

1.  BIO：同步阻塞IO，使用BIO读取数据时，线程会阻塞住，并且需要线程主动去查询是否有数据可读，并且需要处理完一个Socket之后才能处理下一个Socket
2.  NIO：同步非阻塞IO，使用NIO读取数据时，线程不会阻塞，但需要线程主动的去查询是否有IO事件
3.  AIO：也叫做NIO 2.0，异步非阻塞IO，使用AIO读取数据时，线程不会阻塞，并且当有数据可读时会通知线程，不需要线程主动去查询



