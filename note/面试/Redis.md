

### 1. Redis高可用方案

```
1. 哨兵模式(sentinel):
	1. 集群监控:
		负责监控redis master和slave进行是否正常工作
	2. 消息通知:
		如果某个redis实例有故障，那么哨兵负责发送消息作为报警通知给管理员
	3. 故障转移:
		如果master node挂掉了，会自动转移到slave node上
	4. 配置中心:
		如果故障转移了，通知client客户端新的master地址
		
哨兵用于实现redis集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作
	1. 故障转移时，判断一个master node是否宕机了，需要大部分的哨兵都同意才行，涉及到了分布式选举
	2. 即使部分哨兵节点挂掉了，哨兵集群还是能正常工作的
	3. 哨兵通常需要3个实例，来保证自己的健壮性
	4. 哨兵+redis主从的部署结构，是不保证数据零丢失的，只能保证redis集群的高可用
	5. 对于哨兵+redis主从这种复杂的部署架构，尽量在测试环境和生产环境，都进行充足的测试和演练
```

```
2. Redis Sharding是Redis Cluster出来之前的集群方式。其主要思想是采用哈希算法将Redis数据的key进行散列，通过hash函数，特定的key会映射到特定的Redis节点上。java redis客户端驱动jedis，支持Redis Sharding功能，即ShardedJedis以及结合缓存池的ShardedJedisPool

优点:
	非常简单，服务端的Redis实例彼此独立，相互无关联，每个Redis实例像单服务器一样运行，非常容易线性扩展，系统的灵活性很强
缺点:
	由于sharding处理放到客户端，规模进一步扩大时给运维带来挑战
	客户端Sharding不支持动态增删节点，服务端Redis实力群拓扑结构有变化时，每个客户端都需要更新调整，连接不能共享，当引用规模增大时，资源浪费制约优化
```

```
3. Redis Cluster是一种服务端Sharding技术，3.0版本正式提供，采用slot(槽)的概念，一共分成16384个槽，将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行

方案说明:
	1. 通过哈希的方式，将数据分片，每个节点均分布存储一定哈希槽(哈希值)区间的数据，默认分配了16384个槽位
	2. 每份数据分片会存储在多个互为主从的多节点上
	3. 数据写入先写主节点，再同步到从节点(支持配置为阻塞同步)
	4. 同意分片多个节点间的数据不保持强一致性
	5. 读取数据的时候，当客户端操作的key没有分配在该节点上时，redis会返回转向指令，指向正确的节点
	6. 扩容时需要把就节点的数据迁移一部分到新节点

在redis cluster架构下，每个redis要开放两个端口号，一个是6379，另外一个就是加1w的端口号，16379
16379端口号是用来进行节点通信的，也就是cluster bus的通信，用来进行故障检测，配置更新，故障转移授权，cluster bus用了另外一种二进制的协议，gossip协议，用于节点间进行高效的数据交换，占用更少的网络带宽和处理时间

优点:
	1. 无中心架构，支持动态扩容，对业务透明
	2. 具备Sentinel的监控和自动Failover(故障转移)能力
	3. 客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可
	4. 高性能，客户端直连redis服务，免去了proxy代理的损耗
	
缺点:
	1. 运维复杂，数据迁移需要人工干预
	2. 只能使用0号数据库
	3. 不支持批量操作(pipeline管道操作)
	4. 分布式罗即和存储模块耦合
```

### 2. 缓存穿透，缓存击穿，缓存雪崩

```
缓存雪崩是指缓存同一时间大面积失效，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉
解决方案:
	1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生
	2. 给每一个缓存数据增加相应的缓存标记，记录缓存是否失效，如果缓存标记失效，则更新数据缓存
	3. 缓存预热
	4. 互斥锁
```

```
缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉
解决方案:
	1. 接口层增加校验，如用户鉴权校验，id做基础校验，id<=0的直接拦截
	2. 从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value改写为key-null，	缓存有喜爱时间可以设置短点，如30秒(设置太长会导致正常情况也没法使用)，这样可以防止攻击用户反复用同一个id暴力攻击
	3. 采用布隆过滤器(BloomFilter)，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。
```

```
缓存击穿是指缓存中没有蛋数据库中有的数据(一般是缓存时间到期),这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库取数据，引起数据库压力瞬间增大，造成过大压力。换缓存雪崩不同的是，缓存击穿只并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都差不多从而查数据库
解决方案:
	1. 设置热点数据永不过期
	2. 加互斥锁
```

1.  缓存穿透：缓存中查不到，数据库中也查不到

    解决方案：

    	1. 对参数进行合法性校验
    	2. 将数据库中没有查到结果的数据也写入到缓存，这时要注意为了防止Redis被无用小key占满，这一类缓存的有效期要设置得短一点
    	3. 引入布隆过滤器(BloomFilter)，在访问Redis之前判断数据是否存在，要注意布隆过滤器存在一定的误判率，并且，布隆过滤器只能加数据不能减数据

    `布隆过滤器：`

     	1. 如果布隆过滤器判断元素不在一个集合当中，那元素就肯定是不在集合当中
     	2. 如果布隆过滤器判断元素在一个集合当中，这时会存在一定的误判率

2.  缓存击穿：缓存中没有，数据库中有。一般是出现在缓存数据初始化以及key过期了的情况。问题在于，重新写入缓存需要一定的时间，如果是在高并发场景下，过多的请求就会瞬间写到DB上，给DB造成恨到的压力

    解决方案：

    	1. 设置热点缓存永不过期。这时要注意在value当中包含一个逻辑上的过期时间，然后另起一个线程，定期重建这些缓存。
    	2. 加载DB的时候，要防止并发。

3.  缓存雪崩：缓存大面积过期，导致请求都转发到DB

    解决方案：

    	1. 把缓存的失效时间分散开。例如，在原有的统一失效时间基础上，增加一个随机值。
    	2. 对热点数据设置永不过期，这时要注意在value当中包含一个逻辑上的过期时间，然后另起一个线程，定期重建这些缓存。

### 3. 如何保证数据库与缓存的一致性

```
由于缓存和数据库是分开的，无法做到原子性的同时进行数据修改，可能出现缓存更新失败，或者数据库更新失败的情况，这时候会出现数据不一致，影响前端业务
	1. 先更新数据库，再更新缓存，缓存可能更新失败，读到老数据
	2. 先删缓存，再更新数据库，并发时，读操作可能还是会将旧数据读回缓存
	3. 先更新数据库，再删缓存，也存在缓存删除失败的可能
	最经典的缓存+数据库读写的模式，Cache Aside Parttern
	读的时候，先读缓存，缓存没有的话，就读数据库，然后取出数据后放入缓存，同时返回响应
	更新的时候，先更新缓存，然后在删除缓存
```

```
为什么是删除而不是更新？
​	删除更加轻量，延迟加载的一种实现，更新可能涉及多个表，比较耗时
​	延时双删: 先删除缓存，再更新数据库，休眠1s。再次删除缓存，写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据，并发还是可能读到旧值覆盖缓存。

**终极方案:**
	将访问操作串行化:
	  1. 先删除缓存，将更新数据库的操作放进有序队列中
  	  2. 从缓存查不到的查询操作，都进入有序队列
	会面临的问题:
      1.  读请求积压，大量超时，导致数据库的压力: 限流，熔断
      2.  如何避免大量请求积压：将队列水平拆分，提高并行度
      3.  保证相同请求路由正确
```

### 4. 为什么使用缓存？

```
1.  高性能
2.  高可用
```

### 5. 如何保证Redis与数据库的数据一致？

`当我们对数据进行修改的时候，是先删缓存，还是先写数据库？`

1.  如果先删缓存，再写数据库: 在高并发场景下，当第一个线程删除了缓存，还没有来得及写数据库，第二个线程来读取数据，会发现缓存中的数据为空，那就会去读数据库中的数据(旧值，脏数据)。读完之后，把读到的结果写入缓存(此时，第一个线程已经将新的值写到缓存里了)。这样缓存中的值就会被覆盖为修改前的脏数据

    `总结：在这种方式下，通常要求写操作不会太频繁`

    **解决方案:**

    1.  先操作缓存，但是不删除缓存，将缓存修改为一个特殊值(-999)。客户端读缓存时，发现是默认值，就休眠一小会，再去查一次Redis。

        问题: 特殊值对业务有侵入，休眠时间可能会多次重复，对性能有影响。

    2.  延时双删: 先删除缓存，然后再写数据库，休眠一小会，再次删除缓存。

        问题: 如果数据写操作很频繁，同样还是会有脏数据问题

2.  先写数据库，再删缓存：如果数据库写完了之后，缓存删除失败，数据就会不一致

`总结：始终只能保证一定时间内的最终一致性`

​		**解决方案:**

		1. 给缓存设置一个过期时间问题：过期时间内，缓存数据不会更新
		2. 引入MQ，保证原子操作
		3. 将热点数据缓存设置为永不过期，但是在value当中写入一个逻辑上的过期时间，另外起一个后台线程，扫描这些key，对于已逻辑上过期的缓存，进行删除

### 6. 简书Redis主从同步机制

```
1.  从节点执行slaveof masterIp port，保存主节点信息
2.  从节点中的定时任务发现主节点信息，建立和主节点的socket连接
3.  从节点发送信号，主节点返回，两边能互相通信
4.  连接建立后，主节点将所有数据发送给从节点(数据同步)
5.  主节点把当前的数据同步给从节点后，便完成了复制过程。接下来，主节点就会持续的把写命令发送给从节点，保证主从数据一致性

    runId: 每个redis节点启动都会生成唯一的uuid，每次redis重启后，runId都会发生变化
    offset: 主从节点各自维护自己的复制偏移量offset，当主节点有写入命令时，offset = offset + 命令的字节长度。从节点在收到主节点发送的命令后，也会增加自己的offset，并把自己的offset发送给主节点。主节点同时保存自己的offset和从节点的offset，通过对比offset来判断主从节点数据是否一致
    repl_backlog_size: 保存在主节点上的一个固定长度的先进先出队列，默认大小是1MB
    
全量复制:
	1.  从节点发送psync命令，psync runid offset(由于是第一次，runid为？，offset为-1)
	2.  主节点返回FULLRESYNC runId offset，runId是主节点的runId，offset是主节点目前的offset。从节点保存信息
	3.  主节点启动bgsave命令fork子进程进行RDB持久化
	4.  主节点将RDB文件发送给从节点，到从节点加载数据完成之前，写命令写入缓冲区
	5.  从节点清理本地数据并加载RDB，如果开启了AOF会重写AOF
	
部分复制:
	1. 复制偏移量: psync runid offset
	2. 复制积压缓冲区: 当主从节点offset的差距过大超过缓存区长度时，将无法执行部分复制，只能执行全量复制。
		1. 如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓存区的情况)
		2. 如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。
```

![Redis主从同步](Redis.assets/Redis%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.png)

### 7. Redis事务实现

1.  **事务开始**

    MULTI命令的执行，标识着一个事务的开始。MULTI命令会将客户端状态的`flags`属性中打开`REDIS_MULTI`标识来完成的

2.  **命令入队**

    当一个客户端切换到事务状态之后，服务器会根据这个客户端发送来的命令来执行不同的操作。如果客户端发送的命令为MULTI，EXEC，WATCH，DISCARD中的一个，立即执行这个命令，否则将命令放入一个事务队列里面，然后向客户端返回QUEUED回复

     -    如果客户端你发送的命令为EXEC，DISCARD，WATCH，MUTLI四个命令中的其中一个，那么服务器立即执行这个命令

     -    如果客户端发送的是四个命令以外的命令，那么服务器并不理解执行这个命令

          检查命令是否正确，不正确

3.  **事务执行**

    

    

### 8. Redis分布式锁

1.  setnx + setex：存在设置超时时间失败的情况，导致死锁

    setnx：

    ​	加锁，key不存在时，加锁成功，key存在，加锁不成功

    setex：

    ​	给指定存在key设置超时时间。不存在先生成key，加过期时间(原子操作)

    `setnx + setex不是原子操作`

2.  set(key,value,nx,px)：将setnx+setex变成原子操作

    问题：

    -   任务超时，锁自动释放，导致并发问题。使用redisson解决(看门狗监听，自动续期)
    -   以及加锁和释放锁不是同一个线程的问题，在value中存入uuid(线程唯一标识)，删除锁时判断该标识(使用lua保证原子操作)
    -   不可重入，使用redisson解决(实现机制类似AQS，计数)
    -   异步复制可能造成锁丢失，使用redLock解决
        1.  顺序向五个节点请求加锁
        2.  根据一定的超时时间来推断是不是跳过该节点
        3.  三个节点加锁成功并且花费时间小于锁的有效期
        4.  认定加锁成功

### 9. Redis九大数据结构

-   String：字符串
-   List：列表
-   Hash：哈希表
-   Set：无序集合
-   Sorted Set：有序集合
-   bitmap：布隆过滤器
-   GeoHash：坐标，借助Sorted Set实现，通过zset的score进行排序就可以得到坐标附近的其他元素，通过将score还原成坐标值就可以得到元素的原始坐标
-   HyperLogLog：统计不重复数据，用于大数据基数统计
-   Streams：内存班的Kafka

### 10. 缓存过期策略

1.  定时过期：每个设置过期时间的key都需要创建一个定时器，到过期时间就会立即清除。

    `该策略可以立即清除过期的数据，对内存很友好；但是会占用大量的CPU资源，从而影响缓存的响应时间和吞吐量`

2.  惰性过期：只有当访问一个key时，才会判断该key是否已过期，过期则清除。

    `该策略可以最大化节省CPU资源，但是很消耗内存，极端情况可能大量key没有被访问，从而不会被清除`

3.  定期过期：每隔一定时间，会扫描一定数量的数据库的expires字典中一定数量的key(是随机的)，并清除其中已过期的key

    1.  分桶策略：key过期时间点分桶，相应时间点扫描相应时间桶

    ### 11. 分布式系统中常用的缓存方案

-   客户端缓存：页面和浏览器缓存，APP缓存，H5缓存，localStorage和sessionStorage
-   CDN缓存：内存存储：数据的缓存。内容分发：负载均衡
-   nginx缓存：静态资源
-   服务端缓存：本地缓存，外部缓存
-   数据库缓存：持久层缓存（mybatis，hibernate多级缓存），mysql查询缓存
    -   mysql缓存：key-value
        -   key：sql语句
        -   value：结果集
-   操作系统缓存：Page Cache，Buffer Cache

### 12. 布隆过滤器原理，优缺点

-   位图：int[10]，每个int类型的整数是4 * 8 = 32个bit，则int[10]一共有320bit，每个bit非0即1.初始化都是0
-   添加数据时，将数据进行hash得到hash值，对应到bit位，将该bit改为1，hash函数可以定义多个，则一个数据添加会将多个（hash函数个数）bit改为1，多个hash函数的目的是减少hash碰撞的概率
-   查询数据：hash函数计算得到的hash值，对应到bit中，如果有一个0，则说明数据不在bit中，如果都为1，则可能在bit中

优点：

	1. 占用内存小
	2. 增加和查询元素的时间复杂度为：O(k)，(K为哈希函数的个数，一般比较小)，与数据量大小无关
	3. 哈希函数相互之间没有关系，方便硬件并行计算
	4. 布隆过滤器不需要存储元素背身，私密性强
	5. 数据量很大时，布隆过滤器可以表示全集
	6. 使用同一组散列函数的布隆过滤器可以进行交，并，差运算

缺点：

 	1. 误判率，存在假阳性（False Position），不能准确判断元素是否在集合中
 	2. 不能获取元素本身
 	3. 一般情况下不能从布隆过滤器中删除元素

### 13. Redis集群策略

1.  主从模式：

    一主多从，主库可以读写，并且会和从库进行数据同步，主库或从库宕机后，需要手动切换

    难扩容，受限于机器的内存容量，不支持大数据量

2.  哨兵模式：

    主从模式的基础上新增哨兵节点，监控主从，哨兵可以做集群，半数确认

3.  Cluster模式：

    集群模式，支持多主多从，按照key进行槽位分配(16384)，方便扩容，每个主节点可以拥有自己的多个从节点，如果该主节点宕机，会从它的从节点中选举一个新的主节点

Redis要存的数据量不大，可以选择哨兵模式，如果Redis要存的数据量大，并且需要持续的扩容，选择Cluster模式

### 14. 常见缓存淘汰算法

-   FIFO（First In First Out，先进先出），根据缓存被存储的时间，离当前最远的数据优先被淘汰
-   LRU（Least Recenty Used，最近最少使用），根据最新被使用的时间，离当前最远的数据优先被淘汰
-   LFU（Least Frequently Used，最不经常使用），在一段时间内，缓存数据被使用次数最少的优先被淘汰

### 15. Redis主从复制的核心原理

通过执行salveof命令或设置slaveof选项，让一个服务器去复制另一个服务器的数据，主数据库可以进行读写操作

全量复制：

 	1. 主节点通过bgsave命令fork子进程进行RDB持久化，该过程非常消耗cpu，内存（页表复制），硬盘IO
 	2. 主节点通过网络IO将RDB文件发送给从节点
 	3. 从节点清空老数据，载入新RDB文件的过程是阻塞的，无法响应客户端的命令；如果从节点执行bgrewriteaof，也会带来额外的消耗

部分复制：

	1. 复制偏移量：执行复制的双方，主从节点，分别维护一个复制偏移量的offset
	2. 复制积压缓冲区：主节点内部维护了一个固定长度的，先进先出队列作为复制积压缓冲区，而主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制
	3. 服务器运行ID(runid)：每个redis节点，都有其运行id，运行id启动时生成，主节点发送给从节点，从节点把主节点的id存起来。从节点Redis断开重连的时候，就是根据运行id来判断同步的进度：
	  	1. 如果从节点的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制
	  	2. 如果从节点保存的runid与现在的主节点runid不容，说明从节点断线前同步的主节点不是现在的主节点，只能全量复制

### 16. Redis数据结构以及应用场景

1.  字符串（string）：缓存字符串，计数器，session共享，分布式id
2.  哈希表（hash）：存储key-value，更适合用来存储对象
3.  列表（list）：实现栈或队列，可以缓存微信公众号，微博等消息流数据
4.  集合（set）：和列表类似，可以存储多个元素，不能重复，集合可以进行交集，并集，差集操作，从而实现类似，共同关注的人，朋友圈点赞等功能
5.  有序集合（sorted set）：集合是无序的，有序集合可以设置顺序，可以用来实现排行榜的功能

### 17. 持久化机制

Redis基于内存操作，服务器宕机，内存中的数据容易丢失

-   RDB：Redis DataBase，某一时刻的内存快照（Snapshot），以二进制的方式写入磁盘

    -   手动触发：

        -   save命令，是Redis处于阻塞状态

        -   bgsave命令，fork出一个子进程执行持久化，主进程只在fork过程中有短暂的阻塞

            **cow：copy on write（写时拷贝，将共享内存中要写的数据copy出来，子进程读的数据还是原来的数据）,数据隔离**

    -   自动触发：

        -   save m n：在m秒内，如果有n个键发生变化，则自动触发持久化，通过bgsave执行，如果设置多个，只要满足其一就会触发，配置文件有默认配置
        -   flushall：用于清空redis所有的数据库，flushdb情况当前redis所在库数据（默认是0号数据库），会情况RDB文件，同时会生成dump.rdb，内容为空
        -   主从同步：全量同步会自动触发bgsave命令，生成rdb发送给从节点

    优点：

     	1. 整个Redis数据库将只包含一个文件dump.rdb，方便持久化
     	2. 容灾性好，方便备份
     	3. 性能最大化，fork子进程来完成写操作，让主进程继续处理命令，所以是IO最大化，使用单独字进行来进行持久化，主进程不会进行任何IO操作，保证了redis的高性能
     	4. 相对于数据集大时，比AOF的启动效率更高

    缺点：

     	1. 数据安全性低。RDB是间隔一段时间进行持久化，如果持久化之间redis发生故障，会发生数据丢失
     	2. 由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟，会占用CPU

-   AOF：Append Only File。以日志的形式记录服务器所处理的每一个写，删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录，调操作系统命令进程刷盘

    -   所有的写命令会追加到AOF缓冲中

    -   AOF缓冲区根据对应的策略向硬盘进行同步操作

    -   随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的

    -   当Redis重启时，可以夹在AOF文件进行数据恢复

        同步策略：

         	1. 每秒同步：异步完成，效率非常高，一旦系统出现宕机，那么这一秒钟内的数据就会丢失
         	2. 每修改同步：同步持久化，每次发生的数据变化都会被立即记录到磁盘中，最多丢失一条
         	3. 不同步：由操作系统控制，可能丢失较多数据

        优点：

         	1. 数据安全
         	2. 通过append模式写文件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过redis-check-aof工具解决数据一致性问题
         	3. AOF机制的rewrite模式，定期对AOF文件进程重写，以达到压缩的目的

        缺点：

         	1. AOF文件比RDB文件打，且恢复速度慢
         	2. 数据集大的时候，比rdb启动效率低
         	3. 运行效率没有rdb高

### 18. Redis线程模型，单线程为什么这么快

-   Redis基于Reactor模式开发了网络事件处理器，这个处理器叫做文件事件处理器 file event handler。是单线程的，采用IO多路复用机制来同时监听多个Socket，根据Socket上的事件类型来选择对应的时间处理器来处理这个时间。可以实现高性能的网络通信模拟，又可以跟内部其他单线程的模块进行对接，保证了Redis内部的线程模型的简单性

    文件事件处理器的结构包含了4个部分：多个Socket，IO多路复用程序，文件事件分派器以及事件处理器（命令请求处理器，命令回复处理器，连接应答处理器）

    多个Socket可能并发的产生不同的操作，每个操作对应不同的文件事件，但是IO多路复用程序会监听多个Socket，会将Socket放入一个队列中排队，每次从队列中取出一个Socket给事件分派器，事件分派器把Socket给对应的事件处理器

    然后一个Socket的事件处理完之后，IO多路复用程序才会将队列中的下一个Socket给事件分派器，文件事件分派器会根据每个Socket当前产生的时间，来选择对应的事件处理器来处理

-   单线程快的原因（只做读写，操作非常快，适合单线程）：

    -   纯内存操作（不做磁盘IO）
    -   核心是基于非阻塞的IO多路复用机制（主进程只会处理命令，不会处理磁盘IO（fork子进程执行））
    -   单线反而避免了多线程的频繁上下文切换带来的性能问题

### 19. Redis如何设置key的过期时间？实现原理是什么？

Redis设置key的过期时间：

 1.    Expire

 2.    Setex

       实现原理：

        	1. 定期删除：每隔一段时间，执行一次删除过期key的操作
        	2. 惰性删除：当使用get，set等指令去获取数据时，判断key是否过期。过期，就先把key删除，再执行后面的操作

       Redis是将两种方式结合来使用

       -   定期删除：平衡执行频率和执行时长
           -   定期删除时会遍历每个database（默认16个），检查当前库中指定个数的key（默认20个）。随机抽查这些key，如果有过期的就删除
           -   程序中有一个全局变量，记录扫描到了哪个数据库

### 20. Redis和Mysql保持数据一致

-   延时双删
-   互斥锁

### 21. Redis分布式锁

1.  setbx，key不存在获取锁，key存在，获取不到所
2.  lua脚本保证原子性
3.  看门狗续约
4.  redLock，轮询遍历，超过N/2 + 1和节点获取到锁















