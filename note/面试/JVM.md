### 1. GC如何判断对象可以被回收
    1. 引用计数法: 
        新增引用计数+1。引用释放计数-1.计数为0时可以回收
        
        可能会出现A引用了B，B又引用了A，这时候就算他们都不再使用了，但因为相互
        引用，计数器=1，永远无法被回收
    2. 可达性分析法:
        从GC Roots开始向下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots
        没有任何引用链相连时。则证明此对象是不可用的，那么虚拟机就判断是可回收对象
    
        GC Roots的对象:
            1. 虚拟机栈(栈帧中的本地变量表)中引用的对象
            2. 方法区中类静态属性引用的对象
            3. 方法区中常量引用的对象
            4. 本地方法栈中JNI(即一般说的Native方法)引用的对象
    
    可达性算法中的不可达对象并不是立即死亡的，对象拥有一次自我拯救的机会，对象被系统宣告
    死亡至少要经历两次标记过程: 第一次是经过可达性分析发现没有与GC Roots相连接的引用链，
    第二次是在由虚拟机自动创建的finalizer队列中判断是否需要执行finalize()方法
    
    当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则
    直接将其回收，否则，若对象未执行finalize方法，将其放入F-Queue队列，由一低优先级
    线程执行该队列中对象的finalize方法，执行finalize方法之后，GC会再次判断该对象是否
    可达，若不可达，则进行回收，否则，对象"复活"
    
    每个对象只能触发一次finalize方法
    
    由于finalize()方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，不推荐使用

### 2. Java类加载？
    Java的类加载器: 
        AppClassLoader:
            class类文件路径
        ExtClassLoader:
            jdk/jre/lib/ext
        BootstrapClassLoader:
            jdk/jre/lib
    
    类加载器: AppClassLoader,ExtClassLoader -> URLClassLoader 
            -> SecureClassLoader -> ClassLoader
    
    每个类加载器，加载过的类，都有缓存

### 3. Java类加载器
    JDK自带有三个类加载器: BootStrapClassLoader, ExtClassLoader, AppClassLoader
    BoosStrapClassLoader是ExtClassLoader的父类加载器，默认负责加载
    %JAVA_HOME%/lib下的jar包和class文件
    ExtClassLoader是AppClassLoader的父类加载器，负责加载%JAVA_HOME%/lib/ext文件夹
    下的jar包和class文件
    AppClassLoader是自定义类加载器的父类，负责加载classPath下的类文件，是系统类加载器，
    线程上下文加载器
    继承ClassLoader实现自定义类加载器

### 4. 什么是双亲委派，有什么作用？
    双亲委派: 向上委托查找，向下委托加载
    作用: 保护java底层的类不会被应用程序覆盖

### 5. 一个对象从加载到JVM，再到被GC清除，都经历了什么过程？
    类加载过程: 加载 -> 连接 -> 初始化
    加载:
        把Java字节码数据加载到JVM内存当中，并映射成JVM认可的数据结构
    连接:
        分为三个小的阶段: 
            1. 验证: 检查加载到的字节信息是否符合JVM规范
            2. 准备: 创建或接口的静态变量，并赋初始值，半初始化状态
            3. 解析: 把符号引用转为直接引用
    初始化:

### 6. Java内存模型，JVM垃圾回收期？是怎么工作的？什么是STW?都发生在哪些阶段？

    STW: stop-the-world，是在垃圾回收算法执行过程中，需要将JVM内存冻结的一种状态，
        STW状态下，Java的所有线程都是停止执行的，GC线程除外，Native方法可以执行(
        调用的是底层C语言方法)，但是不能与JVM交互，GC算法优化的重点，就是减少STW，
        也是JVM调优的重点
    JVM的垃圾回收器:
        分代算法: 
            年轻代: Serial，ParNew，Parallel Scavenge
            老年代
        Serial: 串行
            优势: 整体过程比较简单，需要GC时，直接暂停，GC完了再继续执行
            劣势: 这个垃圾收集器，是早期垃圾回收器，只有一个线程执行GC，在多CPU架构下，性能
            就会下降严重，只适用于几十兆的内存空间
        Parallel: 并行
            在串行基础上，增加多线程GC，PS+PO这种组合是JDK1.8默认的垃圾收集器
            优势: 在多CPU的架构下，性能会比Serail高很多
        CMS: Concurrent Mark Sweep
            分代算法向不分代算法转变
            核心思想，就是将STW打散，让一部分GC线程与用户线程并发执行
            1. 初始标记阶段: STW只标记出根对象直接引用的对象
            2. 并发标记: 继续标记其他对象，与应用程序是并发执行
            3. 重新标记: STW对并发执行阶段的对象进行重新标记
            4. 并发清除: 并行，将产生的垃圾清除，清除过程中，应用程序又会不断产生
                新的垃圾，叫做浮动垃圾，这些垃圾就要留到下一次GC过程中清除
        G1: Garbage First 垃圾优先
            它的内存模型是实际不分代，但是逻辑上是分代的。在内存模型中，对于堆内存就不再分老年代和新生代，
            而是划分成一个一个的小内存块，叫做Region，每个Region可以隶属于不同的年代
            
            GC分为四个阶段:
                1. 初始标记: 标记出GCRoots直接引用的对象
                2. 标记Region: 通过RSet标记出上一个阶段标记的Region引用到的old区
                    Region
                3. 并发标记阶段:
                    继续标记其他对象，与应用程序是并发执行
                    遍历的范围不再是整个old区，只需要遍历第二步标记出来的Region
                4. 重新标记:
                    对并发标记的对象重新标记
                5. 垃圾清理:
                    与CMS不同的是，G1可以采用拷贝算法，直接将整个Region中的对象拷贝
                    到另一个Region，而这个阶段，G1只选择垃圾较多的Region来清理，
                    并不是完全清理
    
        shennandoah: G1增强
        ZGC: 性能与内存无关，完全不分代

### 7. 什么是三色标记？如何解决错标记和漏标记的问题？为什么要设计这么多的垃圾回收器？

```
三色标记: 是一种逻辑上的抽象，将每个内存对象分成三种颜色: 
	黑色: 表示自己和成员变量都已经标记完毕;
	灰色: 表示自己标记完了，但是成员变量还没有完全标记完;
	白色: 自己未标记完
```

### 8. JVM有哪些垃圾回收算法？

```
MarkSweep: 标记清除算法
	这个算法分为两个阶段:
		标记阶段: 把垃圾内存标记出来
		清除阶段: 直接将垃圾内存回收
	这个算法比较简单，但是有一个很严重的问题，就是会长生大量的内存碎片
Copying: 拷贝算法
	将内存分为大小相等的两半，每次只使用其中一半，垃圾回收时，将当前这一块的存活对象
	全部拷贝到另一半，然后当前这一半内存可以直接清除
	这种算法没有内存碎片，但是它的问题在于浪费空间，而且，它的效率跟存活对象的个数有关
MarkCompack: 标记压缩算法
	这种算法在标记阶段跟标记清除算法是一样的，但是在标记完成之后，不是直接清理垃圾，而是将存活对象往一	端移动，然后将端边界以外的所有内存直接清除
```

### 9. JVM中哪些对象可以作为GC Roots

```
栈中的本地变量
方法区中的静态变量
本地方法栈中的变量
正在运行的线程等可以作为GC Root
```

### 10. JVM中哪些是线程共享区

```
堆区和方法区是所有线程共享的，栈，本地方法栈，程序计数器是每个线程独有的
```

![JVM内存模型](JVM.assets/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-1634178557358.png)

### 11. 如何排查JVM问题

```
对于还在正常运行的系统:
	1. 可以使用jmap来查看JVM中各个区域的使用情况
	2. 可以通过jstack来查看线程的运行情况，比如哪些线程阻塞，是否出现了死锁
	3. 可以通过jstack命令来查看垃圾回收的情况，特别是fullgc，如果发现fullgc比较频繁，那么就得进行调优了
	4. 通过各个命令的记过，或者jvisualvm等工具来进行分析
	5. 首先，初步猜测频繁发生fullgc的原因，如果频繁发生fullgc但是又一直没有出现内存溢出，那么表示	  fullgc实际上是回收了很多对象了，所以这些对象最好能在younggc过程中就直接回收掉，避免这些对象进入到老年代，对于这种情况，就要考虑这些存活时间不长的对象是不是比较大，导致年轻代放不下，直接进入到了老年代，尝试加大年轻代的大小，如果改完之后，fullgc减少，则说明修改有效
	6. 同时，还可以找到占用cpu最多的线程，定位到具体方法，优化这个方法的执行，看是否能避免某些对象的创建，从而节省内存
	
对于已经发生OOM的系统:
	1.一般生产系统中都会设置当系统发生了OOM时，生成当时的dump文件(
		-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/local/base)
	2. 我们可以利用jsisualvm等工具来分析dump文件
	3. 根据dump文件找到异常的实例对象，和异常的线程(占用CPU)高，定位到具体代码
	4. 然后在进行详细的分析和调试
	
	需要分析，推理，实践，总结，再分析，最终定位带具体的问题
```

### 12. JVM中，哪些是共享区，哪些可以作为GC Root

### 13. 一个对象从加载到JVM，再到被GC清除，都经历了什么过程？

```java
method{
    ClassLoaderDemo1 c = new ClassLoaderDemo1();
    c.xxx();
}
	GC
1. 用户创建一个对象，JVM首先要到方法区中区找对象的类型信息，然后再创建对象
2. JVM要实例化一个对象，首先要在堆当中先创建一个对象，-> 半初始化状态
3. 对象首先会分配在堆内存中新生代的Eden，然后经过一次Minor GC，对象如果存活，就会进入S区，在后续的每次GC中，如果对象一直存活，就会在S区来回拷贝。每移动一次，年龄加1。
    多大年龄，才会移入老年代？
        年轻最大15，超过一定年龄后，对象转入老年代。
4. 当方法执行结束后，栈中的指针会移除掉
5. 堆中的对象，经过Full GC，就会被标记为垃圾，然后被GC线程清理掉
```

### 14. 类加载器双亲委派模型

```
JVM在加载类的时候，会委派给Ext和BootStrap进行加载，如果没加载到才由自己进行加载
```

### 15. Java内存结果，堆分为几部分，默认年龄多大进入老年代

```
年轻代
	a. Eden区(8)
	b. From Survivor区(1)
	c. To Survivor区(1)
老年代
	
默认对象的年龄达到15后，进入老年代
```

### 16. 如何进行JVM调优？JVM参数有哪些？怎么查看一个Java进程的JVM参数？

```
JVM调优主要就是通过定制JVM运行参数来提高Java应用程度的运行数据
JVM参数大致可以分为三类:
	1. 标准指令: -开头，这些是所有的HotSpot都支持的参数，可以用java -help打印出来
	2. 非标准指令: -X开头，这些指令通常是跟特定的HotSpot版本对应的，可以用java -X打印出来
	3. 不稳定参数: -XX 开头，这一类参数是跟特定HotSpot版本对应的，并且变化非常大，文档资料较少，在JDK1.8版本下，有几个常用的不稳定指令:
	java -XX:+PrintCommandLineFlags: 查看当前命令的不稳定指令
	java -XX:+PrintFlagsInitial: 查看所有不稳定指令的默认值
	java -XX:+PrintFlagsFinal: 查看所有不稳定指令最终生效的实际值
```

### 17. 什么是字节码？采用字节码的好处是什么？

```
Java中引入了虚拟机的概念，即在机器和编译程序之间加入了一层抽象的虚拟机器，这台虚拟机的机器在任何平台上
都提供给编译程序一个共同的接口
编译程序只需要面向虚拟机，生成虚拟机能够理解的代码，然后由解释器来讲虚拟机代码转换为特定系统的机器码执行。在Java中，这种供虚拟机理解的代码叫做字节码(即扩展名为.class的文件)，它不面向任何特定的处理器，只面向虚拟机
每一种平台的解释器是不同的， 但是实现的虚拟机是相同的，Java源程序经过编译器编译后变成字节码，字节码由虚拟机解释执行，虚拟机将每一条要执行的字节码发送给解释器，解释器将其翻译成特定机器上的机器码，然后在特定机器上运行，这也就解释了Java的编译与解释并存的特点
Java源代码----->编译器------>jvm可执行的Java字节码(即虚拟指令)----->jvm----->jvm中解释器----->
机器可执行的二进制机器码----->程序运行

采用字节码的好处:
	Java语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以Java程序运行时比较搞笑，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译即可子啊多种不同的计算机上运行
```

### 18. 怎么确定一个对象是不是垃圾，什么是GC Root

```
有两种定位垃圾方式:
	1. 引用计数法:
		这种方式是给堆内存中的每个对象记录一个引用个数，引用个数为0就认为是垃圾
		无法解决循环引用问题，会导致内存泄漏 ----------> 内存溢出OOM
	2. 根可达算法:
    	这种方式是在内存中，从引用根对象向下一直找引用，找不到的对象就是垃圾
    	哪些是GC Root？
    		Stack -> JVM Stack,Native Stack,class 类，run-time constant pool常量池，
    		static reference静态变量
```



