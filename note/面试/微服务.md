### 1. 怎么拆分微服务？

1.  微服务之间尽量不要有业务交叉
2.  微服务之前只能通过接口进行服务调用，而不能绕过接口直接访问对方的数据
3.  高内聚，低耦合

高内聚，低耦合，是一种从上而下指导微服务设计的方法，实现高内聚低耦合的工具主要有同步的接口调用和异步的事件驱动两种方式。

DDD：2004年。Eric Evans提出，DDD是面对软件复杂之道。Domain-Driven-Design

Martin-Flower：贫血模型  ---------> 贫血失忆症   充血模型

MVC架构    --------> 领域优先的四层架构

大泥团：不利于微服务的拆分，大泥团拆分出来的微服务依然是泥团，当服务业务逐渐复杂，这个泥团又会膨胀为大泥团

DDD只是一种方法论，没有一个稳定的技术框架，DDD要求领域是跟技术无关，跟存储无关，跟通信无关

所谓中台，就是将各个业务线中可以复用的一些功能抽取出来，剥离个性，提取共性，行程一些可复用的组件。

大体上，中台可以分为三类，业务中台，数据中台和技术中台

电商 收银中台 支付风控中台

中台跟DDD结合：DDD会通过限界上下文将系统拆分成一个个的领域，而这种限界上下文，天生就成了中台之间的逻辑屏障。

DDD在技术与资源调度方面都能够给中台建设提供不错的指导。

DDD分为战略设计和战术设计，上层的战略设计能够很好的指导中台划分，下层的战术设计能够很好的指导微服务搭建。

### 2. 对微服务的理解



微服务是一种架构风格，通过将大型的单体应用划分为比较小的服务单元，从而降低了整个系统的复杂度。

优点：

1.  服务部署灵活：独立部署，不依赖于其他服务，耦合性低
2.  技术更新灵活：可以根据业务特点，灵活选择技术栈。
3.  性能提高：
4.  更容易组合专门的团队：
5.  代码复用：

缺点：

1.  服务调用的复杂度提高了：网络问题，容错问题，负载问题，高并发问题
2.  分布式事务：尽量不要使用微服务事务。
3.  测试的难度提升了：
4.  运维难度提升：

### 3. 微服务敏捷开发，微服务链路追踪，AB发布

开发运维一体化

敏捷开发：提高团队的交付效率，快速迭代，快速试错。

每个月固定发布新版本，以分支的形式保存到代码仓库中。快速入职，任务面板，站立会议，团队人员灵活流动，同时形成各个专家代表。测试环境-生产环境----->开发测试环境，集成测试环境，压测环境，预投产环境，生产环境，文档优先。

链路追踪：

1. 基于日志，形成全局事务ID，落地到日志文件，filebeat-logstash-Elasticsearch行程大型报表。
2. 基于MQ，需要架构支持，经过流式计算形成一些可视化的结果。

持续集成：SpringBoot maven pom -> build -> shell；Jenkins。

AB发布：

1.  蓝绿发布（基于本地），红黑发布（基于云计算），老版本和新版本是同时存在的。
2.  灰度发布，金丝雀发布。

### 4. 什么是服务雪崩？什么是服务限流？

1.  当服务A调用服务B，服务B调用服务C，此时大量请求突然访问服务A，假如服务A本身能抗住这些请求，但是如果服务C扛不住，导致服务C请求堆积，从而服务B请求堆积，从而服务A不可用，这就是服务雪崩，解决方式就是服务降级和服务熔断。
2.  服务限流是指在高并发情况下，为了保护系统，可以对访问的请求进行数量上的限制，从而防止系统不被大量请求压垮，在秒杀中，限流是非常重要的。

### 5. 什么是服务降价？什么是熔断？

### 6. SpringCloud核心组件及其作用

Eureka：服务注册与发现

注册：每个服务向Eureka注册自己提供服务的元数据，包括服务的ip地址，端口号，版本号，通信协议等。

eureka将各个服务维护在了一个服务清单中（双层Map，第一层key是服务名，第二层key是实例名，value是服务地址）。同时对服务维持心跳，剔除不可用的服务，eureka集群个基点相互注册每个实例中都有一样的服务清单。

发现：eureka注册的服务之间调用不需要指定服务地址，而是通过服务名向注册中心咨询，并获取所有服务实例清单（缓存到本地），然后实现服务的请求访问。



Ribbon：服务间发起请求的时候，基于Ribbon做负载均衡，从一个服务的多台机器中选择一台（被调用方的服务地址有多个），Ribbon也是通过发起http请求，来进行的调用，只不过是通过调用服务名的地址来实现的。虽然说Ribbon不用去具体请求服务实例的ip地址或域名了，但是每调用一个接口都还要手动去发起http请求。



Feign：基于Feign的动态代理机制，根据注解和选择的机器，拼接请求URL地址，发起请求，简化服务间的调用，在Ribbon的基础上进行了进一步的封装。单独抽出了一个组件，就是Spring Cloud Feign。在引入Spring Cloud Feign后，我们只需要创建一个接口并用注解的方式来配置它，即可完成对服务提供方的接口绑定。

调用远程就像调用本地服务一样。



Hystrix：发起请求是通过Hystrix的线程池来走的，不同的服务走不同的线程池，实现了不同服务调用的隔离，通过统计接口超时次数返回默认值，实现服务熔断和降级。

Zuul：如果前端，移动端要调用后端系统，统一从Zuul网关进入，有Zuul网关转发请求给对应的服务，通过与Eureka进行整合，将自身注册为Eureka下的应用，从Eureka下获取所有服务的实例，来进行服务的路由。Zuul还提供了一套过滤器机制，开发者可以自己指定哪些规则的请求需要执行校验逻辑，只有通过校验逻辑的请求才会被路由到具体服务实例上，否则返回错误提示。

### 7. 什么是Hystrix？简述实现机制

分布式容错框架

-   组织故障的连锁反应，实现熔断
-   快速失败，实现优雅降级
-   提供实时的监控和告警

资源隔离：线程隔离，信号量隔离

-   线程隔离：Hystrix会给每一个Command分配一个单独的线程池，这样在进行单个服务调用的时候，就可以在独立的线程池里进行，而不会对其他线程池造成影响
-   信号量隔离：客户端需要向依赖服务发起请求时，首先要获取一个信号量才能真正发起调用，由于信号量的数量有限，当并发请求量超过信号量个数时，后续的请求都会直接拒绝，进入fallback流程。信号量隔离主要是通过控制并发请求量，防止请求线程大面积阻塞，以达到限流和防止雪崩的目的。

熔断和降级：调用服务失败后快速失败

熔断是为了防止异常不扩散，保证系统的稳定性

降级：编写好调用失败的补救逻辑，然后对服务直接停止运行，这样这些接口就无法正常调用，但又不至于直接报错，只是服务水平下降。

-   通过HystrixCommand或者HystrixObservableCommand将所有的外部系统（或者称为依赖）包装起来，整个包装对象是单独运行在一个线程之中（这是典型的命令模式）
-   超时请求应该超过定义的阈值
-   为每个依赖关系维护一个小的线程池（或信号量）；如果它变满了，那么依赖关系的请求将立即被拒绝，而不是排队等待。
-   统计成功，失败（由客户端抛出的异常），超时和线程拒绝。



### 8. SpringCloud和SpringCloudAlibaba都有哪些组件？都解决了什么问题？

SpringCloud：提供了构建微服务系统所需要的一组通用开发模式以及一系列快速实现这些开发模式的工具

通常所说的SpringCloud是SpringCloud Netflix，它和SpringCloudAlibaba都是SpringCloud这一系列开发模式的具体实现。

### 9. 什么是服务熔断？什么是服务降级？区别是什么？

1.  服务熔断：当某个服务不可用时，直接返回一个结果，减轻服务压力，直到服务恢复。
2.  服务降级：当系统压力过载时，可以通过关闭某个服务，或限流某个服务来减轻系统压力。

相同点：

1.  都是为了防止系统崩溃
2.  都让用户体验到某些功能暂时不可用

不同点：熔断是下有服务故障触发的，降级是为了降低系统负载。

### 10. 高并发场景下如何实现系统限流

计数器法：

```
将事件划分为固定的窗口大小，例如1s；
在窗口事件段内，没来一个请求，对计数器加1；
当计数器达到设定限制后，该窗口时间内的之后的请求都被丢弃处理；
该窗口时间结束后，计数器清零，从新开始计数。
```

滑动窗口计数法：

```
将时间划分为细粒度的区间，每个区间维持一个计数器，没进入一个请求则将计数器加1
多个区间组成一个时间窗口，没流逝一个区间时间后，抛弃最老的一个区间，纳入新区间
若当前窗口的区间计数器总和超过设定的限制数量，则本窗口内的后续请求都丢弃
```

漏桶算法：如果外部请求超出当前阈值，则会在容器里积蓄，一直到溢出，系统并不关心溢出的流量。从出口处限制请求速率，并不存在计数器法的临界问题，请求曲线始终是平滑的。无法应对突发流量，相当于一个空桶+固定处理线程

令牌桶算法：假设一个大小恒定的桶，这个桶的容量和设定的阈值有关，桶里放着很多令牌，通过一个固定的速率，往里边放入令牌，如果桶满了，就把令牌丢掉，最后桶中可以保存的最大令牌数永远不会超过桶的大小。当有请求进入时，就尝试从桶里取走一个令牌，如果桶里是空的，那么这个请求就会被拒绝。

### 11. SpringCloud各组件功能，与Dubbo的区别

1.  Eureka：注册中心
2.  Ribbon：负载均衡
3.  Feign：基于接口的申明是的服务调用客户端，让调用变得简单
4.  Hystrix：断路器，负责服务容错
5.  Zuul：服务网关，可以进行服务路由，服务降级，负载均衡等
6.  Nacos：分布式配置中心以及注册中心
7.  Sentinel：服务的熔断降级，包括限流
8.  Seata：分布式事务
9.  Spring Cloud Config：分布式配置中心
10.  Spring Cloud Bus：消息总线

Spring Cloud是一个微服务框架，提供了微服务领域中的很多功能组件，Dubbo一开始是一个RPC调用框架，核心是解决服务调用键的问题，Spring Cloud是一个大而全的框架，Dubbo则更侧重于服务调用，所以Dubbo所提供的功能没有Spring Cloud全面，但是Dubbo的服务调用性能比Spring Cloud高，不过Spring Cloud和Dubbo并不是对立的，是可以结合起来使用的。

### 12. SOA，分布式，微服务之间有什么关系和区别

1.  分布式架构是指将单体架构中的各个部分拆分，然后部署到不同的机器或进程中去，SOA和微服务基本上都是分布式架构的
2.  SOA是一种面向服务的架构，系统的所有服务都注册在总线上，当调用服务时，从总线上查找服务信息，然后调用
3.  微服务是一种更彻底的面向服务的架构，将系统汇总各个功能个体抽成一个个小的应用程序，基本保持一个应用对应的一个服务的架构。

### 13. Spring Cloud和Dubbo有哪些区别

Spring Cloud是一个微服务框架，提供了微服务领域中的很多组件功能组件，Dubbo一开始是一个RPC调用框架，核心是解决服务调用的问题，Spring Cloud是一个大而全的框架，Dubbo则更侧重与服务调用，所以Dubbo所提供的功能没有Spring Cloud全面，但是Dubbo的服务调用性能比Spring Cloud高，不过Spring Cloud和Dubbo并不是对立的，是可以结合起来使用的。

### 14. Spring Cloud有哪些常用组件，作用是什么

-   Eureka：注册中心
-   Nacos：注册中心，配置中心
-   Consul：主责中心，配置中心
-   Spring Cloud Config：配置中心
-   Feign/OpenFeign：RPC调用
-   Kong：服务网关
-   Zuul：服务网关
-   Spring Cloud Gateway：服务网关
-   Ribbon：负载均衡
-   Spring Cloud Sleuth：链路追踪
-   Zipkin：链路追踪
-   Seata：分布式事务
-   Dubbo：RPC调用
-   Sentinel：服务熔断
-   Hystrix：服务熔断















