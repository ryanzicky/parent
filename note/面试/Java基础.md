### 1. == 和 equals比较
    ==: 比较的是栈中的值，基本数据类型是变量值，引用类型是堆中内存对象的地址
    equals: object中默认也是采用==比较，通常会重写

    public static void main(String[] args) {
        String a = "aaa";
        String b = new String("aaa");
        String c = b; // 引用传递

        System.out.println(a == b); // false
        System.out.println(a == c); // false
        System.out.println(b == c); // true
        System.out.println(a.equals(b)); // true
        System.out.println(a.equals(c)); // true
        System.out.println(b.equals(c)); // true
    }

### ArrayList 和 LinkedList 区别
    ArrayList: 基于动态数组,连续内存存储,适合下标访问(随机访问),扩容机制: 因为数组长度固定，超出长度
        存数据时需要新建数组，然后将老数组的数据拷贝到新数组，如果不是尾部插入数据还会涉及到元素的移动
        (往后复制一份，插入新元素)，使用尾插法并制定初始容量可以极大提升性能，甚至超过linkedList(需要
        创建大量的node对象)

        数组，查询快，增加删除慢
    
    LinkedList: 基于链表，双端队列，可以存储在分散的内存中，适合做数据插入及删除操作，不适合查询: 需要逐一遍历，
        遍历LinkedList必须使用iterator不能使用for循环，因为每次for循环体内通过get(i)取得某一元素时
        都需要对list重新进行遍历，性能消耗极大
        另外不要试图使用indexOf等返回元素索引，并利用其进行遍历，使用indexOf对list进行了遍历，当结果
        为空时会遍历整个列表
    
        链表，增加删除快，查询慢

    ArrayList更适合随机查找，LinkedList更适合删除和添加，查询，添加，删除的时间复杂度不同
    ArrayList和LinkedList都实现了List接口，LinkedList额外实现了Deque接口，所以LinkedList可以当做双端队列来使用

### ConcurrentHashMap的扩容机制
    1.7版本
        1. 1.7版本的ConcurrentHashMap是基于Segment分段实现的
        2. 每个Segment相当于一个小型的HashMap
        3. 每个Segment内部会进行扩容，和HashMap的扩容逻辑类似
        4. 先生成新的数组，然后转移元素到新数组中
        5. 扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值

        数据结构: ReentrantLock + Segment + HashEntry,一个Segment中包含一个HashEntry数组，每个
            HashEntry又是一个链表结构
        元素查询: 二次Hash，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部
        锁: Segment分段锁，Segment继承了ReenTrantLock，锁定操作的Segment，其他的Segment不受影响，
            并发度为Segment个数，可以通过构造函数指定，数组扩容不会影响其他的Segemtn
        get方法无需加锁，volatile保证

    1.8版本
        1. 1.8版本的ConcurrentHashMap不再基于Segment实现
        2. 当某个线程进行put时，如果发现ConcurrentHashMap正在进行扩容那么该线程一起进行扩容
        3. 如果某个线程put时，发现没有正在进行扩容，则将key-value添加到ConcurrentHashMap中，然后判断是否超过阈值，
            超过了则进行扩容
        4. 扩容之前也先生成一个新的数组
        5. 在转移元素时，现将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组或多组的元素转移工作
        
        数据结构: Synchroized + CAS + Node + 红黑树，Node的val和next都用volatile修饰，保证可见性
            查找，替换，赋值操作都使用CAS
        锁: 锁链表的head节点，不影响其他元素的读写，锁粒度更细，效率更高，扩容时，阻塞所有的读写操作，并发扩容
        读操作无锁: 
            Node的val和next使用volatile修饰，读写线程对该变量互相可见
            数组用volatile修饰，保证扩容时被读线程感知

### final
    1. 简述final的作用？
        最终的
            · 修饰类: 表示类不可被继承
            · 修饰方法: 表示方法不可被子类覆盖，但是可以重载
            · 修饰变量: 表示变量一旦被赋值就不可以更改它的值
        1. 修饰成员变量
            · 如果final修饰的是类变量，只能在静态初始化块中指定初始值或者声明该类变量时指定初始值
            · 如果final修饰的是成员变量，可以在非静态初始化块，声明该变量或者构造器中执行初始值
        2. 修饰局部变量
            系统不会为局部变量进行初始化，局部变量必须由程序显示初始化，因此使用final修饰局部变量时，
            即可以在定义时指定默认值(后面的代码不能对变量再赋值)，也可以不指定默认值，而在后面的代码中
            对final变量赋初始值(仅一次)
        3. 修饰基本类型数据和引用类型数据
            · 如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改
            · 如果是引用类型的变量，则再其初始化之后便不能再让其指向另一个对象。但是引用的值是可变的
        
    2. 为什么局部内部类和匿名内部类只能访问局部final变量？
        首先需要知道的一点是: 内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行
        完毕就被销毁
        这里就会产生问题: 当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在(只有没有人再
        引用它时，才会死亡)。这里就出现了一个矛盾: 内部类对象访问了一个不存在的变量。为了解决这个问题，就将
        局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍然可以访问它，实际访问的是局部
        变量的"copy"。这样就好像延长了局部变量生成周期

    将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变量，
    方法中的局部变量也的跟着改变
    就将局部变量设置为final，对它初始化后，就不让再修改这个变量，就保证了内部类的成员变量和方法的局部变量
    的一致性。使得局部变量与内部类建立的拷贝保持一致

### HashCode与equals
    hashCode()的作用是获取哈希码，也称为散列码;它实际上是返回一个int整数，这个哈希码的作用是确定该对象在哈希
    表中的索引位置。hashCode()定义在Object.java 中，Java中的任何类都包含有hashCode()函数。
    散列表存储的是键值对(key-set)，它的特点是: 能根据"键"快速的检索出对应的"值"，这其中就用到了散列码。

    为什么要有hashCode
        对象加入hashSet时，HashSet会先计算对象的hashCode值来判断对象加入的位置，看该位置是否有值，
        如果没有，HashSet会假设对象没有重复出现，但是如果发先有值，这时会调用equals()方法来检查两个
        对象是否真的相同，如果两者相同，HashSet就不会让其加入操作成功，如果不同的话，就会重新三列到其他
        位置，这样就大大减少了equals的次数，相应就大大提高了执行速度

    1. 如果两个对象相等，则hashCode一定是相同的
    2. 两个对象相等，对两个对象分别调用equals方法都返回true
    3. 两个对象有相同的hashcode值，它们也不一定是相等的
    4. 因此.equals()方法被覆盖过，则hashCode方法也必须被覆盖
    5. hashCode()的默认行为是对堆上的对象产生独特值，如果没有重写hashCode()，则该
        class的两个对象无论如何都不会相等(即使这两个对象指向相同的数据)

### HashMap扩容机制
    1.7 版本
        1. 先生成新数组
        2. 遍历老数组中的每个位置上的链表上的每个元素
        3. 取每个元素的key，并基于新数组长度，计算出每个元素在新数组中的下标
        4. 将元素添加到新数组中去
        5. 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性

    1.8 版本
        1. 先生成新数组
        2. 遍历老数组中的每个位置上的链表或红黑树
        3. 如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去
        4. 如果是红黑树，则先遍历红黑树，先计算出红黑树中每个元素对应在新数组中的下标位置
            a. 统计每个校标位置的元素个数
            b. 如果该位置上的元素个数超过了8，则生成一个新的红黑树，并将根节点的添加到新数组的对应位置
            c. 如果该位置下的元素个数没有超过8，则生成一个新的链表，并将链表的头结点添加到新数组的对应位置
        5. 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性
    
### HashMap和HashTable的区别？底层实现是什么？
    区别:
        1. HashMap方法没有Synchroized，线程非安全，HashTable线程安全
        2. HashMap允许key和value为null，而HashTable不允许

    底层实现: 数组+链表实现
        jdk8开始链表高度到8，数组长度超过64，链表转变为红黑树，元素以内部类Node节点存在
        1. 计算key的hash值，二次hash然后对数组长度取模，对应到数组下标
        2. 如果没有产生hash冲突(下标位置没有元素)，则直接创建Node存入数组
        3. 如果产生hash冲突，先进行equals比较，相同则取代该元素，不同，则判断链表高度插入链表，
            链表高度达到8，并且数组长度达到64则转变为红黑树，长度低于6则将红黑树转回链表
        4. key为null，存在下标0的位置

### Java中的异常体系
    Java中的所有异常都来自顶级父类Throwable
    Throwable下有两个子类Exception和Error
    Error是程序无法处理的错误，一旦出现这个错误，则程序将被迫停止运行
    Exception不会导致程序停止，又分为两个部分RunTimeException运行时异常和CheckedException检查异常
    RUNTimeException常常发生在程序运行过程中，会导致程序当前线程执行失败，CheckedException常常发生
    在程序编译过程中，会导致程序编译不通过

### JDK,JRE,JVM的区别和联系
    JDK:
        Java Development Kit Java开发工具
    JRE:
        Java Runtime Environment Java运行时环境
    JVM:
        Java Virtual Machine Java虚拟机

### List和Set的区别
    List: 有序，按对象进入的顺序保存对象，可重复，允许多个null元素对象，可以使用Iterator取出所有元素，
        再逐一遍历，还可以使用get(int index)获取指定下标的元素
    Set: 无序，不可重复，最多允许有一个null元素，取元素时只能用Iterator接口取的所有元素，再逐一遍历

### String，StringBuffer，StringBuilder的区别
    1. String是不可变的，如果尝试去修改，会新生成一个字符串对象，StringBuffer和StringBuilder是可变的
    2. StringBuffer是线程安全的，StringBuilder是线程不安全的，所以在单线程环境下StringBuilder效率更高

    String是final修饰的，不可变，每次操作都会产生新的String对象
    StringBuffer和StringBuilder都是在原对象上操作
    StringBuffer是线程安全的，StringBuilder是线程不安全的
    StringBuffer方法都是synchronized修饰的
    性能: StringBuilder > StringBuffer > String

    场景: 经常需要改变字符串内容使使用StringBuffer和StringBuilder
    有限使用StringBuilder，多线程使用共享变量时使用StringBuffer

### jdk1.7到jdk1.8 HashMap发生了什么变化？(底层)
    1. 1.7中底层是数组+链表，1.8中底层是数组+链表+红黑树，加红黑树的目的是提高HashMap插入和查询整体效率
    2. 1.7中链表插入使用的是头插法，1.8中链表插入使用的是尾插法，因为1.8插入key和value时需要判断链表元素个数，
        所以需要遍历链表统计链表元素个数，所以正好直接使用尾插法
    3. 1.7中哈希算法比较负责，存在各种右移与异或运算，1.8中进行了简化，因为复杂的哈希算法的目的就是提高三烈性，
        来提高HashMap的整体效率，而1.8中新增了红黑树，所以可以适当的简化哈希算法，节省CPU资源

### jdk1.7到jdk1.8虚拟机发生了什么变化？
    1.7 中存在永久代，1.8中没有永久代，替换它的是元空间，元空间所占的内存不是在虚拟机内部，而是本地内存空间，
    这么做的原因是，不管是永久代还是元空间，他们都是方法区的具体实现，之所以元空间所占的内存改成本地内存，官方的
    说法是为了和JRockit统一，不过额外还有一些原因，比如方法区所存储的类信息通常是比较难确定的，所以对于方法区的
    大小是比较难指定的，太小了容易出现方法区溢出，太大了又会占用了太多虚拟机的内存空间，而转移到本地内存后则不会
    影响虚拟机所占用的内存

### ArrayList和LinkedList的区别
    1. 底层数据结构不同，ArrayList底层是基于数组实现的，LinkedList是基于链表实现的
    2. 由于底层数据结构不同，适用场景不同，ArrayList更适合随机查找，LinkedList更适合删除和添加，
        查询，添加，删除的复杂度不同
    3. 另外ArrayList和LinkedList都实现了List接口，但是LinkedList还额外实现了Deque接口，
        所以LinkedList还可以当做双端队列来使用

    ArrayList添加元素扩容

### HashMap的put方法
    1. 根据key通过哈希算法与与运算得出数组下标
    2. 如果数组下标位置元素为空，则将key和valye封装为Entry对象(JDK1.7是Entry对象，JDK1.8中是Node对象)
        并放入该位置
    3. 如果数据下标位置元素不为空，则要分情况讨论
        a. 如果是1.7，则先判断是否需要扩容，如果要扩容就进行扩容，如果不用扩容就生成Entry对象，并使用头插法
            添加到当前位置的链表中
        b. 如果是1.8，则先判断当前位置上的Node的类型，看是红黑树Node，还是链表Node
            1. 如果是红黑树Node，则将key和value封装为一个红黑树节点并添加到红黑树中，在这个过程中会判断
                红黑树中是否存在当前key，如果存在则更新value
            2. 如果此位置上的Node对象是链表节点，则将key和valye封装为一个链表Node并通过尾插法插入到链表
                的最后位置去，因为是尾插法，所以需要遍历链表，在遍历链表的过程中会判断是否存在当前key，如果存在
                则更新value，当遍历完链表后，将新链表Node插入到链表后，会看当前链表的节点个数，如果大于等于8，那么
                则会将该链表转变成红黑树
            3. 将key和value封装为Node插入到链表或红黑树中后，再判断是否需要进行扩容，如果需要就进行扩容，
                不需要就结束put方法

### 接口和抽象类的区别
    1. 抽象类可以存在普通成员函数，而接口中只能存在public abstract方法
    2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的
    3. 抽象类只能继承一个，接口可以实现多个
    
    接口的设计目的，是对类的行为进行约束
        接口是对行为的抽象，表达的是like a的关系
    抽象类的设计目的，是代码复用
        抽象类是对类本质的抽象，表达的是is a的关系
    
    使用场景: 当你关注一个事务的本质的时候，用抽象类;当你关注一个操作的时候，用接口
    
    抽象类的功能要远超过接口，但是，定义抽象类的代价高，因为高级语言来说(从实际设计上来说也是)每个类只能
    继承一个类，在这个类中，你必须继承或编写出其所有子类的所有共性。虽然接口在功能上会弱化许多，但是它只是
    针对一个动作的描述，而且你可以在一个类中同时实现多个接口，在设计阶段会降低难度

### 泛型中Extends和super的区别
    1. <? extends T>表示包括T在内的任何T的子类
    2. <? super T>包括T在内的任何T的父类

### 深拷贝和浅拷贝
    深拷贝和前考本就是指对象的拷贝，一个对象中存在两种类型的属性，一种是基本数据类型，一种是实例对象的引用
    1. 浅拷贝是指，只会拷贝基本数据类型的值，以及实例对象的引用地址，并不会复制一份引用地址所指向的对象，
        也就是浅拷贝出来的对象，内部的类属性指向的是同一个对象
    2. 深拷贝是指，既会拷贝基本数据类型的值，也会针对实例对象的引用地址所指向的对象进行复制，深拷贝出来的对象，
        内部属性指向的不是同一个对象

### ConcurrentHashMap的扩容机制
    1.7版本
        1. 1.7版本的ConcurrentHashMap是基于Segment分段实现的
        2. 每个Segment相当于一个小型的HashMap
        3. 每个Segment内部会进行扩容，和HashMap的扩容逻辑类似
        4. 先生成新的数组，然后转移元素到新数组中
        5. 扩容的判断也是每个Segment内部单独判断的，判断是否超过阈值

    1.8版本
        1. 1.8版本的ConcurrentHashMap不再基于Segment实现
        2. 当某个线程进行put时，如果发现ConcurrentHashMap正在进行扩容那么该线程一起进行扩容
        3. 如果某个线程put时，发现没有正在进行扩容，则将key-value添加ConcurrentHashMap中，
            然后判断是否超过阈值，超过了则进行扩容
        4. ConcurrentHashMap是支持多个线程同时扩容的
        5. 扩容之前也先生成一个新的数组
        6. 在转移元素时，先将原数组分组，将每组分给不同的线程来进行元素的转移，每个线程负责一组
            或多组的元素转移工作

### ConcurrentHashMap如何保证线程安全，jdk1.8有什么变化
    
### 面向对象
    封装:
        封装的意义，在于明确标识出允许外部使用的所有成员函数和数据项
        内部细节对外部调用透明，外部调用无序修改或者关心内部实现
        1. javabean的属性私有，提供get/set对外访问
        2. orm框架
    继承:
        继承基类的方法，并做出自己的改变和/或扩展
        子类共性的方法或者属性直接使用父类的，而不需要自己在定义，只需扩展自己个性化的
    多态:
        基于对象所属类的不同，外部对同一个方法的调用，实际执行的逻辑不通
        继承，方法重写，父类引用指向子类对象
        无法调用子类独有的方法

### 重载和重写的区别
    重载: 发生在同一个类中，方法名必须相同，参数类型不同，个数不同，顺序不同，方法返回值和访问修饰符可以不同，
        发生在编译时
        public int add(int a, Stirng b)
        public String add(int a, Stirng b)
        // 参数类型，个数，顺序都相同，返回类型不同，不是重载，编译报错
    
    重写: 发生在父子类中，方法名，参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，
        访问修饰符范围大于等于父类;如果父类方法访问修饰符为private则子类就不能重写该方法

    
    
    
