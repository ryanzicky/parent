### Redis的单线程和高性能
    Redis的单线程主要是指Redis的网络IO和键值对读写是由一个线程来完成的，这也是Redis
    对外提供键值存取服务的主要流程。但Redis的其他功能，比如持久化，异步删除，集群数据
    同步等，其实是由额外的线程执行的。

### Redis单线程为什么还能这么快?
    因为它所有的数据都在内存中，所有的运算都是内存级别的运算，而且单线程避免了多线程
    的切换性能损耗问题。正因为Redis是单线程，所以要小心使用Redis指令，对于那些耗时
    的指令(比如keys),一定要谨慎使用，一不小心就可能会导致Redis卡顿。

### Redis单线程如何处理那么多的并发客户端连接？
    Redis的IO多路复用: Redis利用rpoll来实现IO多路复用，将连接信息和事件放到队列中，
    依次放到文件事件分派器，事件分派器将事件分发给事件处理器。

### Redis持久化
    RDB快照(Snapshot)
    在默认情况下，Redis将内存数据库快照保存在名字为dump.db的二进制文件中。
    你可以对Redis进行设置，让它在"N秒内数据集至少有N次改动"这一条件被满足时，自动保存一次数据集
    比如说，一下设置会让Redis在满足"60秒内有至少有1000个键被改动"这一条件时，自动保存一次数据集
    # save 60 1000 // 关闭RDB只需要将所有的save保存策略注释掉即可。
    
    AOF(append-only file)
    快照功能并不是非常耐久: 如果Redis因为某些原因而造成故障停机，那么服务器将丢失最近写入，且仍未保存到快照中的那些数据。从1.1版本开始，Redis增加了一种完全耐久的持久方式: AOF持久化，将修改的每一条指令记录进文件appendonly.aof中(先写入os cache，每隔一段时间fsync到磁盘)。
    
    RDB:
    	启动优先级低，体积小，恢复速度快，容易丢数据
    AOF:
    	启动优先级高，体积大，恢复速度慢，根据策略配置
    	
    混合持久化:

### Redis主从工作原理

```
1. slave节点启动给master节点发送psync命令请求复制数据
2. master节点收到psync命令执行bgsave生成最新rdb快照数据
3. master开始做rdb之后新数据的缓存，当持久化进行完成以后，master会把这份rdb文件数据集同步给slave节点
4. slave节点会清空老数据并加载主节点rdb文件，将数据加载到内存中
5. master再将之前缓存再内存中的命令发送给slave
6. slave执行buffer里的写命令到内存
7. master通过socker长连接持续把写命令发送给从节点，保证主从数据一致性
```

### Redis lua脚本
    不要在lua脚本中出现死循环和耗时的计算，否则redis会阻塞，将不接受其他的命令
    所以使用时要注意不能出现死循环，耗时的运算。redis是单进程，单线程执行脚本，
    管道不会阻塞redis

### Redis哨兵高可用架构
    client -> sentinel集群 -> redis集群

### Redis Cluster集群
    Redis 单节点  10G
    Redis集群与哨兵区别：
        数据分片存储，大集群分成小集群，小集群数据不重叠
        hash算法定位数据所在集群

        小集群可以横向扩容，水平扩展1万多个，官网推荐不超过1千(通信效率降低)

    集群分片：
        16384 逻辑分片 slot(hash槽)
        集群三个节点，hash槽划分：
            1 - 5000 第一个节点
            5001 - 10000 第二个节点
            10001 - 16383 第三个节点
    
### Redis集群数据分片算法

### Redis集群Master选举原理

### Redis集群脑裂问题

### Redis集群水平扩缩容

### Redis集群方案比较
    1. 哨兵模式
        在Redis3.0以前的版本要实现集群一般是借助哨兵sentinel工具来监控master节点的状态，如果
        master节点异常，则会做主从切换，将某一台slave作为master，哨兵的配置略显复杂，并且性能
        和高可用性等各方面表现一般，特别是在主从切换的瞬间存在访问瞬断的情况，而且哨兵模式只有一个
        主节点对外提供服务，没法支持很高的并发，且单个主节点内存也不宜设置得过大，否则会导致持久化
        文件过大，影响数据恢复或主从同步的效率。
    
    2. 高可用集群模式
        Redis集群是一个由多个主从节点群组成的分布式服务器群，它具有复制，高可用和分片特性。Redis
        集群不需要sentinel哨兵，也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，
        这种集群模式没有中心节点，可水平扩展，据官方文档称可以线程扩展到上万个节点(官方推荐不超过
        1000个节点)，Redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常方便。
    

### Redis集群原理分析
    Redis Cluster将所有数据划分为16384个slots(槽位),每个节点负责其中一部分槽位，槽位的信息存储于每个节点中
    当Redis Cluster的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地，这样当客户端
    查找某个key时，可以直接定位到目标节点，同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制
    来实现槽位信息的校验调整。

    槽位定位算法：
        Cluster默认会对key的值使用crc16算法进行hash得到一个整数值，然后用这个整数值对16384进行取模来得到具体槽位
        HASH_SLOT = CRC16(key) mod 16384

    跳转重定位：
        当客户端向一个错误的节点发出了指令，该节点会发现指令的key所在的槽位并不归自己管理，这时它会向客户端发送一个特殊
        的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据，客户端收到指令后除了跳转到正确的节点上去操作，
        还会同步更新纠正本地的槽位映射表缓存，后续所有key将使用新的槽位映射表。

    Redis集群节点间的通信机制：
        redis cluster节点间采取gossip协议进行通信
            1. 维护集群的元数据(集群节点信息，主从角色，节点数量，各节点共享的数据等)有两种方式：集中式和gossip
        集中式：
            优点在于元数据的更新和读取，时效性非常好，一旦元数据出现变更立即就会更新到集中式的存储中，其他节点读取的时候
            立即就可以感知到；不足在于所有的元数据的更新压力全部集中在一个地方，可能导致元数据的存储压力，很多中间件都会
            借助zookeeper集中式存储元数据。

        gossip：
            gossip协议包含多种消息，包括ping，pong，meet，fail等等
            meet: 某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信；
            ping: 每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元素数据，互相通过ping交换
                  元数据(类似自己感知到的集群节点增加和移除，hash slot信息等);
            pong: 对ping和meet消息的返回，包含自己的状态和其他信息，也可以用于信息广播和更新;
            fail: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。

        gossip协议的优点在于元数据的更新比较分散，不是几种在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，
            降低了压力;缺点在于元数据更新有延时可能导致集群的一些操作会有一些滞后。

    Redis集群选举原理分析：
        当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave，
        从而存在多个slave竞争成为master节点的过程，其过程如下：
        1. slave发现自己的master变为Fail
        2. 将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST信息
        3. 其他节点收到的该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack
        4. 尝试failover的slave收集master返回的FAILOVER_AUTH_ACK
        5. slave收到超过半数master的ack后变成新master(这里解释了集群为什么至少需要三个主节点),如果只有两个，当其中一个挂了，
            只剩一个主节点是不能选举成功的.
        6. slave广播Pong消息通知其他集群节点

    集群脑裂数据丢失问题：
        redis集群没有过半机制会有脑裂问题，网络分区导致脑裂后多个主节点对外提供写服务，一旦网络分区恢复，会将其中一个主节点变为从节点，
        这时会有大量数据丢失
        规避方法可以在redis配置里加上参数(这种方法不可能百分百避免数据丢失，参考集群leader选举机制)：
        min-replicas-to-write 1 // 写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，比如集群总共三个节点可以配置1，
                                    加上leader就是2，超过了半数
        注意: 这个配置一定程度上会影响集群的可用性，比如slave要是少于1个，这个集群就算leader正常也不能提供服务了，需要具体场景权衡选择。

### Redis集群为什么至少需要三个master节点，并且推荐节点数为奇数
    因为新master的选举需要大于半数的集群master节点同意才能选举成功，如果只有两个master节点，当其中一个挂了，是达不到选举新master的条件的
    奇数个master节点可以在满足选举条件的基础上节省一个节点，比如三个master杰斯安和四个master节点的集群相比，大家如果都挂了一个master节点
    都能选举新master节点，如果都挂了两个master节点都没法选举新master节点了，所以奇数的master节点更多的是从节省机器资源角度出发说的。

### 哨兵选举流程
    当一个master服务器被某sentinel视为下线状态后，该sentinel会与其他sentinel协商选选出sentinel的leader进行故障转移工作。每个发现master
    服务器进入下线的sentinel都可以要求其他sentinel选自己为sentinel的leader，选举是先到先得。同时每个sentinel每次选举都会自增配置纪元(选举周期)，
    每个纪元只会选择一个sentinel为leader。如果所有超过一半的sentinel选举某sentinel作为leader。之后该sentinel进行故障转移操作，从存活的
    slave中选举出新的master，这个选举过程跟集群的master选举很类似。
    哨兵集群只有一个哨兵节点，redis的主从也能正常运行以及选举master，如果master挂了，那唯一的那个哨兵节点就是哨兵leader了，可以正常选举新master。
    不过为了高可用一般都推荐至少部署三个哨兵节点，为什么推荐奇数个哨兵节点原理跟集群奇数个master节点类似。

### Redis 基本特性
    1. 非关系型的键值对数据库，可以根据键以O(1)的时间复杂度取出或插入关联值
    2. Redis 的数据是存在内存中的
    3. 键值对中键的类型可以是字符串，整型，浮点型等，且键是唯一的
    4. 键值对中的值类型可以是string, hash, list, set, sorted set等
    5. Redis内置了复制，磁盘持久化，LUA脚本，事务，SSL，ACLs，客户端缓存，客户端代理等功能
    6. 通过Redis哨兵和Redis Cluster模式提供高可用性

    SDS: simple dynamic string
        1. 二进制安全的数据结构
        2. 提供了内存预分配机制，避免了频繁的内存分配
        3. 兼容C语言的函数库
    
    K - V: 
        key: string
        value: string, hash, set, sorted set, list

        map -> dict
        数据库: 海量数据的存储
        1. 数组： O(1)
        2. 链表： O(N)
        3. 树：log(N)
        4. hash(key) -> 自然数
            hash碰撞：
                1. 开放地址法 -> 
                2. 链表法 -> (链表)头插法， 同一个hash槽
    
        字符串最大长度byte：2^32 - 1 byte
        字符串最大长度字节：(2^32 - 1) / 8
        最大KB：(2^32 - 1) / 8 / 1024
        最大MB：(2^32 - 1) / 8 / 1024 / 1024
        右移(偏移)操作相当于除以: bitoffset >> 3 ===========>  bitoffset / 8

    扩容：
        渐进式rehash
    
### Redis 数据结构
    List:
        List是一个有序(按加入的时序排序)的数据结构，Redis采用quicklst(双端链表)和ziplist作为list的底层实现
        可以通过设置每个ziplist的最大容量，quicklist的数据压缩范围，提升数据存取效率
        list-max-ziplist-size -2   // 单个ziplist节点最大能存储8kb，超过则进行分裂，将数据存储在新的ziplist节点中
        list-compress-depth    1   // 0 代表所有节点，都不进行压缩，1 代表从头节点往后走一个，尾节点往前走一个不用压缩，其他的全部压缩，2，3，4...以此类推
    
    Hash:
        Hash数据结构底层实现为一个字典(dict)，也是RedisDB用来存储K-V的数据结构，当数据量比较小，或者单个元素比较小时，底层用ziplist存储，
        数据大小和元素数量阈值可以通过如下参数设置
        hash-max-ziplist-entries 512  // ziplist 元素个数超过512,将改为hashtable编码
        hash-max-ziplist-value    64  // 单个元素大小超过64bytes,将改为hashtable编码

    Set:
        Set为无序的，自动去重的集合数据类型，Set数据结构底层实现为一个value为null的字典(dict),当数据可以用整型表示时。Set集合将被编码为intset数据结构,
        当以下两个条件任意满足时Set将用hashtable存储数据：
            1. 元素个数大于 set-max-intset-entries
                set-max-intset-entries 512  // intset能存储的最大元素个数，超过则用hashtable编码
            2. 元素无法用整型表示

    intset:
        整数集合是一个有序的，存储整型数据的结构，整型集合在Redis中可以保存int16_t,int32_t,int64_t类型的整型数据，并且可以保证集合中不会出现重复数据

    ZSet:
        ZSet是有序的，自动去重的集合数据类型，ZSet数据结构底层实现为字典(dict) + 跳表(skiplist),当数据比较少时，用ziplist编码结构存储
        zset-max-ziplist-entries 128   // 元素个数超过128，将用skiplist编码
        zset-max-ziplist-value    64   // 单个元素大小超过64byte，将用skiplist编码

    Ziplist:
    Skiplist:

    GeoHash算法:
        GeoHash是一种地理位置编码方法，它将地理位置编码为一串简短的字母和数字。它是一种分层的空间数据结构，将空间细分为网格形状的桶，
        这是所谓的z熟悉怒曲线的众多应用之一，通常叫空间填充曲线。

### Redis应用场景
    1. 计数器
        可以对String进行自增自减运算，从而实现计数器功能，Redis这种内存型数据库的读写性能非常高
    2. 分布式ID生成
        利用自增特性，一次请求一个大一点的步长如incr 2000，缓存再本地使用，用完在请求
    3. 海量数据统计
        位图(bitmap): 存储是否参加过某次活动，是否已读某篇文章，用户是否为会员，日活统计
    4. 会话缓存
        可以使用Redis来同意存储多台应用服务器的会话信息，当应用服务器不再存储用户的会话信息，也就不再具有状态，
        一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性
    5. 分布式队列/阻塞队列
        List是一个双向链表，可以通过 lpush/rpush 和rpop/lpop 写入和读取消息，可以通过使用 
        brpop/blpop 来实现阻塞队列

### Redis 6.0新特性
    1. 多线程模型
        默认单线程，配置开启多线程
    2. 客户端缓存(单机环境)
    3. 权限控制
        
### Redis 缓存设计
    1. 多级缓存架构
        1. nginx层
            本地缓存
        2. web应用层
        3. 应用缓存
        4. redis缓存
    2. 缓存穿透&缓存击穿&缓存雪崩
        1. 缓存穿透
            数据库不存在的数据
    3. 热点缓存key重建优化
    4. 缓存与数据库双写不一致
    5. Redis开发规范与性能优化
    

    