### 整个Zookeeper就是一个多节点分布式一致性算法的实现，底层采用的实现协议是ZAB
    
### ZAB协议
    ZAB协议全称: Zookeeper Atomic Broadcast(Zookeeper原子广播协议)
    Zookeeper是一个为分布式应用提供高效且可靠的分布式协调服务。在解决分布式一致性方面，Zookeeper并没有使用Paxos，而
    是采用ZAB协议，ZAB是Paxos算法的一种简化实现
    ZAB协议定义: ZAB下一是为分布式协调服务Zookeeper专门设计的一种支持崩溃恢复和原子广播的协议
    基于该协议，Zookeeper实现了一种主备模式的系统架构来保持集群各个副本之间数据一致性

    所有客户端写入数据都是写入到Leader节点，然后，由Leader复制到Followe节点中，从而保证数据一致性
    复制过程类似两阶段提交(2PC),ZAB只需要Follower(含Leader自己的Ack)有一半以上返回Ack信息就可以执行提交，大大减少了同步阻塞，也提高了
    可用性
    整个Zookeeper就是在消息广播和崩溃恢复两个模式之间来回切换，简而言之，当Leader服务可以正常使用，就进入消息广播模式，
    当Leader不可用时，则进入崩溃恢复模式
    
    消息广播:
        ZAB协议的消息广播过程使用的是一个原子广播协议，类似一个两阶段提交过程，对于客户端发送的写请求，全部由Leader接收，
        Leader将请求封装成一个事务Proposal，将其发送给所有Follower，然后根据Follower的反馈，如果超过半数(含Leader自己)
        成功响应，则执行commit操作
        
        1. Leader在收到客户端请求之后，会将这个请求封装成一个事务，并给这个事务分配一个全局递增的唯一ID，称为事务ID(ZXID).
        ZAB协议需要保证事务的顺序，因此必须将每一个事务按照ZXID进行先后排序然后处理，主要通过消息队列实现
        2. 在Leader和Follower之间还有一个消息队列，用来解耦他们之间的耦合，解除同步阻塞
        3. Zookeeper集群中纬保证任何所有进程能够有序的顺序执行，只能是Leader服务器接受写请求，即使是Follower服务器接受到客户端的
        写请求，也会转发到Leader服务器进行处理，Follower只能处理读请求
        4. ZAB协议规定了如果一个事务在一台机器上被处理(commit)成功，那么应该在所有的机器上都被处理成功，哪怕机器出现了故障崩溃

    崩溃恢复:
        当Leader崩溃时，即进入崩溃恢复模式(崩溃即:Leader失去了与过半Follower的联系)
        假设1: Leader在复制数据给所有Follower之后，还没来得及收到Follower的Ack返回就崩溃了，怎么办？
        假设2: Leader在收到Ack并提交了自己，同时发送了部分Commit出去之后崩溃怎么办？

        针对这些问题，ZAB定义了2个原则:
            1. ZAB协议确保丢弃哪些只在Leader提出/复制，但没有提交的事务
            2. ZAB协议确保那些已经在Leader提交的事务最终会被所有服务器提交
            
            所以，ZAB设计了下面这样一个选举算法:
                能够确保提交已经被Leader提交的事务，同时丢弃已经被跳过的事务
                针对这个要求，如果让Leader选举算法能够保证新选举出来的Leader服务器拥有集群中所有机器ZXID最大的事务，那么就能够
                保证这个新选举出来的Leader一定具有所有已经提交的提案。
                而且这么做有一个好处是: 可以省去Leader服务器检查事务的提交和丢弃工作的这一步操作

    数据同步:
        当崩溃恢复之后，需要在正式工作之前(接收客户端请求)，Leader服务器首先确认事务是否都已经被过半的Follower提交了，即是否完成了数据
        同步，目的是为了保持数据一致
        当Follower服务器成功同步之后，Leader会将这些服务器加入到可用服务器列表中
        实际上，Leader服务器处理或丢弃事务都是依赖着ZXID的，那么这个ZXID如何生成呢
        答: 在ZAB协议的事务编号ZXID设计中，ZXID是一个64位的数字，其中32位可以看作是一个简单的递增的计数器，针对客户端的每一个事务请求，
        Leader都会产生一个新的事务Proposal并针对该计数器进行+1操作
        而高32位则代表了Leader服务器上取出本地日志中最大事务Proposal的ZXID，并从该ZXID中解析出对应的epoch值(leader选举周期)，
        当一轮先的选举结束后，会对这个值加一，并且事务id又从0开始自增
        
        64位ZXID: LeaderID(32位)，事务ID(32位)
        高32位代表了每代Leader的唯一性，低32位代表了每代Leader中事务的唯一性，同时，也能让Follower通过高32位识别不同的Leader，简化了
        数据恢复流程
        基于这样的策略: 当Follower连接上Leader之后，Leader服务器会根据自己服务器上最后被提交的ZXID和Follower上的ZXID进行比对，
        比对结果要么回滚，要么和Leader同步
        